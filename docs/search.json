[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R Guide",
    "section": "",
    "text": "Welcome to “Introduction to R”\nHere, you will learn how to use R for data analysis. Try practice questions, and feel free to contact me anything you have questions.",
    "crumbs": [
      "Welcome to \"Introduction to R\""
    ]
  },
  {
    "objectID": "Structure_of_R_Studio_1.html",
    "href": "Structure_of_R_Studio_1.html",
    "title": "1  Structure of R Studio",
    "section": "",
    "text": "1.1 Creating a Project\nR is a programming language. R Studio is a UI that helps you write, run, and organize your R code. Let’s explore how R Studio looks and what each section does.\nWhen we write codes and save data, it’s important to keep everything organized so that R can remember where things were saved. To tell R Studio where to save and find your files, we use project. It’s like a home for your codes and data.\nLet’s make a new project.\nCongrats! You just made your first project in R. Now let’s start exploring what features are there in R Studio.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Structure of R Studio</span>"
    ]
  },
  {
    "objectID": "Structure_of_R_Studio_1.html#creating-a-project",
    "href": "Structure_of_R_Studio_1.html#creating-a-project",
    "title": "1  Structure of R Studio",
    "section": "",
    "text": "Click “File -&gt; New Project -&gt; New Directory -&gt; New Project”\nChoose location of folder you want to be, a good name, and click “Create Project”",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Structure of R Studio</span>"
    ]
  },
  {
    "objectID": "Structure_of_R_Studio_1.html#ui-of-r-studio",
    "href": "Structure_of_R_Studio_1.html#ui-of-r-studio",
    "title": "1  Structure of R Studio",
    "section": "1.2 UI of R Studio",
    "text": "1.2 UI of R Studio\nOn the main page of R Studio, you’ll see 4 main sections.\n\n1 – Script Editor: This is where you write and save your code.\n2 – Console: It’s a communication window between you and the computer. You can give him commands to execute, and console will show you what it’s doing.\n3 – Environment: You’ll work with countless variables. This section shows what variables you’ve saved as you run your code.\n4 – Directories: Sometimes you need to load data or files for your code. This section shows which files are in your working folder. Default is folder where your project is.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Structure of R Studio</span>"
    ]
  },
  {
    "objectID": "Structure_of_R_Studio_1.html#using-console",
    "href": "Structure_of_R_Studio_1.html#using-console",
    "title": "1  Structure of R Studio",
    "section": "1.3 Using Console",
    "text": "1.3 Using Console\nSo Console is where actual works are done. Let’s try using it. Input 1 + 1 and press enter. You’ll see it’s printing 2, the result of what you asked R to calculate.\n\nHowever, Console is one-time-communicator. It can’t remember anything you say or R executes, making you to retype everything to do same job. This gets annoying fast, especially if your code gets long. How can we make this easy? We’ll figure it out in next the next section.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Structure of R Studio</span>"
    ]
  },
  {
    "objectID": "Structure_of_R_Studio_1.html#creating-a-script",
    "href": "Structure_of_R_Studio_1.html#creating-a-script",
    "title": "1  Structure of R Studio",
    "section": "1.4 Creating a script",
    "text": "1.4 Creating a script\nScript is a file that saves your code so that you don’t have to rewrite same thing every time. Let’s make a script. There are two ways to create a script.\n\nScript and Quarto Document are most common files used to save the codes. Difference between to are what the default text is.\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nScript (Talking to computer)\nPlain texts are considered as code, and you need to use special characters to insert “comments.” It’s for purely performing code it’s written.\n\n\nQuarto Document (Talking to human)\nPlain texts are considered as text, and you need to insert “Chunks” to tell R Studio ‘These are codes I want to run.’ You can export Quarto Doc as beautiful report, which Script can’t.\n\n\n\nThis year, we’ll use Quarto Doc as we need to create reports and share codes to others.\nCreate Quarto Doc. You can use whatever title and Author name you want. Leave other options as it is.\n\n1 – # in the doc indicates the title. The more # you put, the smaller the text size gets. # (biggest) -&gt; ####(Smallest)\n2 – Area that wrapped with {r} and is called “Chunk,” where codes you want to run goes. # in the chunks indicates comment, which will not get executed.\n3 – When you click Run, you’ll see which part of doc you want to execute. If you click specific chunk and “Run Current Chunk,” only clicked chunk will be executed. This is one advantage of Quarto doc too.\nNow, save your quarto doc and Render. You’ll see that (Title).html file is created in your directory (1-&gt;2-&gt;3 marked in the picture). Congrats! You just created your first report using R. When you open the file, you’ll see how quarto doc became visually pretty and clear.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Structure of R Studio</span>"
    ]
  },
  {
    "objectID": "Variables_Calculations_2.html",
    "href": "Variables_Calculations_2.html",
    "title": "2  Data Types and Variables",
    "section": "",
    "text": "2.1 Data Types\nNow, let’s talk about how data are saved in R. R classifies data into four categories: Number, Text, Boolean, Special.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data Types and Variables</span>"
    ]
  },
  {
    "objectID": "Variables_Calculations_2.html#data-types",
    "href": "Variables_Calculations_2.html#data-types",
    "title": "2  Data Types and Variables",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nNumber\nAny numbers. They’re classified into two categories.\nInteger – Type of number WITHOUT decimals.\nE.g.) 1, 10, 100\n\nFloat – Type of number WITH decimals.\nE.g) 1.24, 2.00 (Not int because of “.00”!)\n\n\nText\nAnything you put into “ “, regardless of what’s inside.\nE.g) “Hi”, “121”\n\n\nBoolean\nA logic data. It’s either “True” or “False”\n\n\nSpecial\nValues that cannot be specified\nNull – Empty value without determined data type (Number/Text/Boolean)\nNA – Missing value. Known data type but nothing inside.\nNaN – Unable to mathematically define. E.g.) Saving “Hi” as int/float\n\ninf – Yes, infinite number. They’re under special characters!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data Types and Variables</span>"
    ]
  },
  {
    "objectID": "Variables_Calculations_2.html#variables",
    "href": "Variables_Calculations_2.html#variables",
    "title": "2  Data Types and Variables",
    "section": "2.2 Variables",
    "text": "2.2 Variables\nNow we know that there are multiple types of data. But how do we tell R to remember them? That’s where variables come in! Variables are names that store data values.\nYou can declare a variable by using the assignment operator ‘&lt;-’ or ‘=’.\n\nTest1 &lt;- 3\nTest2 = 4\n\nOnce you declare the variable, you’ll see them in the Environment tab. Also, you’ll be able to call them by simply typing their names.\n\nTest1\n\n[1] 3\n\nTest2\n\n[1] 4\n\n\nIf it’s not working, it’s probably due to variable names. There’re specific rules in naming - First character must be dot(.) or letter. It cannot be number or special character. Second character and later can be anything - You cannot use other function’s name as variable name (sum, mean, etc. We’ll cover functions as we go on) - Variable names are case-sensitive. “test” and “Test” are different variables. - Avoid using spaces in variable names. Use dot(.) or underscore(_) instead. E.g.) my.variable, my_variable",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data Types and Variables</span>"
    ]
  },
  {
    "objectID": "Variables_Calculations_2.html#simple-calculations",
    "href": "Variables_Calculations_2.html#simple-calculations",
    "title": "2  Data Types and Variables",
    "section": "2.3 Simple Calculations",
    "text": "2.3 Simple Calculations\nHere, we’ll review basic operators in program language.\n\n\n\nType\nOperation\n\n\n\n\nAddition\n+\n\n\nSubtraction\n-\n\n\nMultiplication\n*\n\n\nRemainder\n%\n\n\nExponents\n/\n\n\n\nTry some on the script you made! Also, you can use variables in calculations.\n\nTest1 + Test2\n\n[1] 7\n\n\nThere are multiple functions that will make calculations easy\n\n\n\n\n\n\n\nOperation\nDescription\n\n\nceiling(x)\nRound x up as “int”\nE.g.) 3.4 (float) becomes 3 (int)\n\n\nfloor(x)\nRound x down as “int”\n\n\ntrunc(x)\nDrop decimals as “float”\nE.g.) 3.4 (float) becomes 3.0 (float)\n\n\nround(x, digits = n)\nRound x as “float” at nth decimal place.\ndefault (If you omit “digits =n”) is to round at ones place.\n\n\nsqrt(x)\n\\(\\sqrt{x}\\)\n\n\nexp(x)\n\\(e^x\\)\n\n\nlog(x, base = n)\n\\(\\log_{n}(x)\\). Default is base with n = e\n\n\nsin(x), cos(x), etc.\nTrig functions!\n\n\nFactorial(n)\nn! = 1 x 2 x 3 x … x n\n\n\nOthers\nThere are many other function!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data Types and Variables</span>"
    ]
  },
  {
    "objectID": "Variables_Calculations_2.html#logical-calculations",
    "href": "Variables_Calculations_2.html#logical-calculations",
    "title": "2  Data Types and Variables",
    "section": "2.4 Logical Calculations",
    "text": "2.4 Logical Calculations\nSometimes you need more than simple calculations, such as “which number is bigger?” Return values of logical calculations are Boolean (True/False).\n\n\n\nType\nOperation\n\n\n\n\nComparison\n&lt;, &gt;, &lt;=, &gt;=\n\n\nEqual\n==\n\n\nNot Equal\n!=\n\n\nOr\n|\n\n\nAnd\n&",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data Types and Variables</span>"
    ]
  },
  {
    "objectID": "Vectors_3.html",
    "href": "Vectors_3.html",
    "title": "3  Vectors",
    "section": "",
    "text": "3.1 Vectors with Numbers\nLast chapter, we reviewed what variables are. Imagine we’re storing heights of 50 students. Declaring 50 variables like “Height1”, “Height2”, …, “Height50” takes forever. Instead, we can use “vector” to store multiple values in a single variable.\nVector is a 1-dimensional sequence of “same type” of data. For example, vector with int can only store int values. Length of Vector is equal to number of values stored in the vector.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "Vectors_3.html#vectors-with-numbers",
    "href": "Vectors_3.html#vectors-with-numbers",
    "title": "3  Vectors",
    "section": "",
    "text": "3.1.1 Ways to create vectors\n\ny &lt;- c(2, 4, 6, 8, 10)\ny\n\n[1]  2  4  6  8 10\n\n\nAgain, vector must be same data type. For example, if you create one with mix of int and float, all values will be float. Why? because all int can be float by adding “.0” but float cannot be int without losing data. Let’s see an example.\n\nx &lt;- c(1,3,5,7,9.2)\nx\n\n[1] 1.0 3.0 5.0 7.0 9.2\n\n\nRecall c() meant to “connect.” This means you can connect multiple vectors into one as long as they match data type.\n\nz &lt;- c(x, y)\nz\n\n [1]  1.0  3.0  5.0  7.0  9.2  2.0  4.0  6.0  8.0 10.0\n\n\nQuestion: What will happen if we flip the order of element? As you can see below, resulting order of elements in the vector also changes.\n\nz &lt;- c(y, x)\nz\n\n [1]  2.0  4.0  6.0  8.0 10.0  1.0  3.0  5.0  7.0  9.2\n\n\nNow we learned how to create vectors with number. But what if we want to label something and need 1 to 100? Typing them manually will take some time. Instead, there’s a short cut to create continuous numbers with “:” operator. There there two points to remember when using :.\n\nIt has fixed increment of 1.\nIt follows the order from the left to the right. Check the example below.\n\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n10:1\n\n [1] 10  9  8  7  6  5  4  3  2  1\n\n0.2:3\n\n[1] 0.2 1.2 2.2\n\n\nWhat if you want to create vector with different increment? You can use seq() function. It has three main arguments - from, to, by. “from” is where the sequence starts, “to” is where it ends, and “by” is the increment.\n\nseq(1, 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(1, 10, by=2)\n\n[1] 1 3 5 7 9\n\nseq(length=5, from=1, by=2)\n\n[1] 1 3 5 7 9\n\n\nIf you want to create vector with repeated values, you can use rep() function. It has two main arguments - “x” and “times”. “x” is the value you want to repeat, and “times” is how many times you want to repeat it.\n\nrep(5, times=4)\n\n[1] 5 5 5 5\n\n\n\n\n3.1.2 Calculations with Vectors\n\nElement wise operation Just like how we perform calculations with single numbers, we can do the same with vectors. One strong advantage of R is that it’s one of rare programming languages that can perform “vectorized” calculations. This means you can perform calculations using same position of different vectors without complex logics. Let’s perform example calculation using vectors we created.\n\n\nx &lt;- seq(0, 40, by = 10)\ny &lt;- c(1:5)\n\nx + y\n\n[1]  1 12 23 34 45\n\nx * y\n\n[1]   0  20  60 120 200\n\n\n\n\n\n\n\n\nRecycling rule What if the length of vectors are different? In this case, R will recycle the shorter vector until it matches the length of longer vector. Check the example below.\n\n\nz &lt;- c(rep(x, times=2), 50)\nz + y\n\nWarning in z + y: 두 객체의 길이가 서로 배수관계에 있지 않습니다\n\n\n [1]  1 12 23 34 45  1 12 23 34 45 51\n\n\nAs you can see, addition is performed even though length of two vectors didn’t match. The warning sign is indicating that length’s are not multiple of each other, so it shows what we mean by “recycle until it matches the length.” If it’s difficult to grasp, there’s a visualization below.\n\n\n\n\n\n\n\n3.1.3 Functions helpful for numeric vectors\nThere are many functions that can be used with numeric vectors. Here are some of the most commonly used ones. While you might not end up not using them all, try them out and see which ones are useful for you!\n\n\n\n\n\n\n\nOperation\nDiscription\n\n\n\n\nlength(x)\nReturn length of the vector\n\n\nsum(x)\nReturn sum of all elements in the vector\n\n\nmean(x)\nReturn average of all elements\n\n\nmedian(x)\nReturn median of all elements\n\n\nvar(x)\nReturn variance of all elements\n\n\nsd(x)\nReturn standard deviation of all elements\n\n\nmax(x)\nmin(x)\nrange(x)\nReturn highest number in the vector\nReturn lowest number in the vector\nReturn the range (highest and lowest) number\n\n\nrank(x)\nReturn the “ranking” of each element from smallest to biggest\n\n\nsort(x)\nReorganize vector from smallest to biggest elements\n\n\norder(x)\nReturn index of smallest to biggest element’s location\n\n\nwhich.max(x)\nwhich.min(x)\nReturn the highest number’s index\nReturn the lowest number’s index\n\n\nwhich(x)\nReturn index of whatever element that satisfies the condition\n\n\n\nrank/sort/order can be confusing, so here’s the example.\n\nx &lt;- c(11,14,12,13,15)\nx\n\n[1] 11 14 12 13 15\n\n\n\n# Rank returns the ranking of each element in entire vector\nrank(x)\n\n[1] 1 4 2 3 5\n\n\n\n# Order returns Where the element is located in the original vector if we sorted it\norder(x)\n\n[1] 1 3 4 2 5\n\n\n\n# Sort returns the vector sorted from smallest to biggest\nsort(x)\n\n[1] 11 12 13 14 15",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "Vectors_3.html#vectors-with-boolean",
    "href": "Vectors_3.html#vectors-with-boolean",
    "title": "3  Vectors",
    "section": "3.2 Vectors with Boolean",
    "text": "3.2 Vectors with Boolean\nJust like numeric vectors, you can create vectors with Boolean values (TRUE/FALSE). You can use c() function to create them. You can use T/F instead too.\n\nbooleanvec &lt;- c(TRUE, FALSE, TRUE, TRUE, FALSE)\nbooleanvec\n\n[1]  TRUE FALSE  TRUE  TRUE FALSE\n\n\nSpecial point about the Boolean vectors is that you can use logical operators to create vectors. Let’s say you want to know which students scored higher than 60 on their final.\n\nscores &lt;- c(55, 70, 65, 40, 90)\npassed &lt;- scores &gt; 60\npassed\n\n[1] FALSE  TRUE  TRUE FALSE  TRUE\n\n\n\n3.2.1 Functions you should know for Boolean vectors\nWhile it’s not literally a boolean logic, there are some functions that can be useful when working with Boolean vectors: any/all/if/else\nany() statement returns TRUE if at least one element in the vector is TRUE.\n\nany(passed)\n\n[1] TRUE\n\n\nall() statement returns TRUE only if all elements in the vector are TRUE.\n\nall(passed)\n\n[1] FALSE\n\n\nif and else statements are fundemental for all programming languages. They allow you to control the flow of your program based on conditions. However, we’ll discuss about it briefly here since other contents are heavy as well. If you want to learn more about it, let me know anytime.\nif statement returns true when the condition is met. It’s like a gateway before executing next code. “Do if condition is met? Then move to next line of code. If not, then skip to else statement (or end the if statement).”\nelse statement is executed when the if condition is not met. It’s like the alternative path when the if condition fails.\nBoth if and else statements are wrapped around {}.\nHere’s the example:\n\nIftest &lt;- c(1,3,5,7,9)\n\nif (any(Iftest &gt; 5)) \n  {\n  print(\"At least one element is greater than 5\")\n} else \n  {\n  print(\"No elements are greater than 5\")\n}\n\n[1] \"At least one element is greater than 5\"\n\n\nFor readability, R allows you to combine ifelse into a single line. It looks like this: ifelse(Condition, Value if TRUE, Value if FALSE)\n\nifelse(any(Iftest &gt; 5), \"At least one element is greater than 5\", \"No elements are greater than 5\")\n\n[1] \"At least one element is greater than 5\"",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "Vectors_3.html#vectors-with-text",
    "href": "Vectors_3.html#vectors-with-text",
    "title": "3  Vectors",
    "section": "3.3 Vectors with Text",
    "text": "3.3 Vectors with Text\nJust like other two types, this is just vector with a sequence of text values. You can create them using c() function.\n\nnames &lt;- c(\"Banana\", \"Apple\", \"Carrot\", \"Grape\", \"Whatelse\")\nnames\n\n[1] \"Banana\"   \"Apple\"    \"Carrot\"   \"Grape\"    \"Whatelse\"\n\n\nUnlike numbers, you can’t add or subtract texts. So there’s other ways to handle manipulation of text vectors.\n\n3.3.1 Functions helpful for text vectors\nFirst, we should check if all elements are text, as vector require everything to be same type. But in huge data set, it might be tough to manually check everything. So we have “.ascharacter()” function to convert everything into text.\n\nmixedvec &lt;- c(\"Apple\", 2, \"Banana\", 4.5, TRUE)\nmixedvec &lt;- as.character(mixedvec)\nmixedvec\n\n[1] \"Apple\"  \"2\"      \"Banana\" \"4.5\"    \"TRUE\"  \n\n\nTry code by yourself. Did you notice that all inputs are as text when they were originally text, int, float, bool?\nNow, let’s look at how we can combine and split text vectors like addition/substraction. Both cases, they follow same element wise operation and recycle rule like numeric vectors.\nFor combining text vectors, we can use paste() function. If you want to add space between combined texts, use sep=” ” argument. One point is that you can paste how many vectors you want, but you can call sep =” ” one once per line. So if you want to have different seperators between multiple vectors, you’ll need to call paste() multiple times. So it’ll look like this:\n\nnames &lt;- c(\"Banana\", \"Apple\", \"Carrot\", \"Grape\", \"Whatelse\")\nprice &lt;- c(\"1.00\", \"2.50\", \"0.75\")\ncombined &lt;- paste(names, price, sep=\": $\") #Combine name and price with \": $\" in between\ncombined #Do you notice recycling rule here?\n\n[1] \"Banana: $1.00\"   \"Apple: $2.50\"    \"Carrot: $0.75\"   \"Grape: $1.00\"   \n[5] \"Whatelse: $2.50\"\n\n\nFor spliting text vectors, we can use strsplit() function. When you split, you use split=” ” argument to specify where to split.\n\nsplitnames &lt;- strsplit(combined, split=\": \")\nsplitnames #Name and price are seperated using \":\" as the split point\n\n[[1]]\n[1] \"Banana\" \"$1.00\" \n\n[[2]]\n[1] \"Apple\" \"$2.50\"\n\n[[3]]\n[1] \"Carrot\" \"$0.75\" \n\n[[4]]\n[1] \"Grape\" \"$1.00\"\n\n[[5]]\n[1] \"Whatelse\" \"$2.50\"   \n\n\nThere are many other functions that’s helpful with handling vectors. However, due to it’s amount, we’ll mention only few that’s commonly used.\n\n\n\n\n\n\n\nOpertiona\nDescription\n\n\n\n\nnchar(x)\nReturn character counts of each elements in the vector x. *Literally all characters, including space, are counted!\n\n\nsubstr(x, start, stop)\nReturn character counts of each element in the vector x, starting from ’start’th character to the ’stop’th character.\n\n\ngrep(target, x, ignore.case=T, fixed=T)\nReturn the index of element in vector x that contains “target”. ignore.case asks if you want grep() to be case sensitive (T as yes). fixed asks if you want to use Regex (We don’t be discussing about this here. Keep it true)\n\n\nsub(target, replacement, x, ignore.case=T, fixed=T)\nIf any element in vector x contains “target,” replace it to “replacement.”\n\n\ntoupper(x)\ntolower(x)\nchange all characters in the vector x into upper/lower case",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "Vectors_3.html#other-vectors-with-special-data-tpyes",
    "href": "Vectors_3.html#other-vectors-with-special-data-tpyes",
    "title": "3  Vectors",
    "section": "3.4 Other vectors with special data tpyes",
    "text": "3.4 Other vectors with special data tpyes\nEarlier, we said there’s a special data types. During data analysis, handling these becomes essential as we don’t know how data that doesn’t align with your dataset will influence the general trend (hence analysis result). So let’s briefly look at how to create vectors with these special data types, especially Na and NaN.\n\n3.4.1 Vectors with NA\nNA is used to represent missing values with undetermined data type. For example, if you’re collecting final exam scores but completely missed one student’s score, you can use NA to represent it.\nHow we do process NA without manually checking all data? We can use is.na() and na.omit() functions. is.na() checks if there is NA values, and na.omit() removes all NA values from the vector.\n\nscores &lt;- c(90, 85, NA, 70, 95, NA, 80)\nis.na(scores)  #It'll return TRUE if there's NA in the vector\n\n[1] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE\n\n\n\nscores &lt;- na.omit(scores)  #It'll remove all NA\nscores\n\n[1] 90 85 70 95 80\nattr(,\"na.action\")\n[1] 3 6\nattr(,\"class\")\n[1] \"omit\"\n\n\nLook at the output of na.omit(). Second/Fourth line - attr() shows what type of work is by the code. Ignore them First line - Vector after removing NA values Third line - Attribute showing which index values were removed due to NA Fifth line - What’s done by the code (removing NA values)\nHowever, using is.na() and na.omit() everytime can be time-consuming in big dataset. How can we “ignore” them without removing them? Many functions in R have “na.rm” argument. Setting na.rm=T will ignore NA values during calculation.\n\nscores &lt;- c(90, 85, NA, 70, 95, NA, 80)\nmean(scores, na.rm=T)  #Calculate mean while ignoring NA values\n\n[1] 84\n\n\n\n\n3.4.2 Vectors with NaN\nNaN is used to represent mathematically undefined values. For example, if you try to divide 0 by 0, the result is undefined even thought we know that data type is numbers. In this case, R will return NaN. Just like NA, we can use is.nan() function to check if there’s NaN values in the vector. To know if vector actually contains NaN, you must use is.nan() because is.na() will return TRUE for both NA and NaN.\n\n\n3.4.3 Index\nI mentioned “index” multiple times before, and you probably grasped somewhat sense of what it is. Index is a location of element in the vector. In R, index starts from 1 (not 0 like other programming languages). You can use index to call specific elements in the vector by indicating interested index in []. Here’s the example:\n\nx &lt;- c(10, 20, 30, 40, 50)\nx[3]  #Call the 3rd element in the vector x\n\n[1] 30\n\n\nBut one thing to be careful is that you cannot call two indicies at once. Try x[3,5] and see if it works.\nInstead, you can use c() to connect multiple indices.\n\nx &lt;- c(10, 20, 30, 40, 50)\nx[c(2,4)]  #Call 2nd and 4th elements in the vector x\n\n[1] 20 40",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "Matrix_4.html",
    "href": "Matrix_4.html",
    "title": "4  Matrix",
    "section": "",
    "text": "4.1 Creating a matrix\nVector was a 1-dimensional data, meaning each vector can hold one type. For example, if we create vector of heights, all elements must be height numbers. However, what if we want need to hold details about the data? For example, height by gender?\nMatrix is a 2-dimensional data structure, holding rows and columns. Just like vector, matrix must hold one type of data.\nThere’s two ways to declare matrix.\nc &lt;- 1:10\n\nm &lt;- matrix(c, nrow = 2, ncol = 5)\nm\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5    7    9\n[2,]    2    4    6    8   10\nHere, did you notice the order of elements? R fills the matrix by column first, then row. If you want to fill by row first, use byrow = TRUE option.\nm &lt;- matrix(c, nrow = 2, ncol = 5, byrow = TRUE)\nm\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    6    7    8    9   10\nv1 &lt;- c(1, 2, 3)\nv2 &lt;- c(4, 5, 6)\nm_row &lt;- rbind(v1, v2)\nm_row\n\n   [,1] [,2] [,3]\nv1    1    2    3\nv2    4    5    6\nm_col &lt;- cbind(v1, v2)\nm_col\n\n     v1 v2\n[1,]  1  4\n[2,]  2  5\n[3,]  3  6\nOne thing to consider is the recycling rule. Whenever you’re working with data sets, having different dimensions will cause shorter data set to repeat.\nv1 &lt;- c(1,2,3)\nv3 &lt;- c(7, 8)\nm_row2 &lt;- rbind(v1, v3)\n\nWarning in rbind(v1, v3): number of columns of result is not a multiple of\nvector length (arg 2)\n\nm_row2\n\n   [,1] [,2] [,3]\nv1    1    2    3\nv3    7    8    7\nWith a same logic, you can create matrix by combining vector with matrix or matrix with matrix using bind() functions.\nc &lt;- 1:10\nrbind(c, 11:20)\n\n  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\nc    1    2    3    4    5    6    7    8    9    10\n    11   12   13   14   15   16   17   18   19    20",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Matrix</span>"
    ]
  },
  {
    "objectID": "Matrix_4.html#creating-a-matrix",
    "href": "Matrix_4.html#creating-a-matrix",
    "title": "4  Matrix",
    "section": "",
    "text": "Dividing vector into rows and columns with matrix()\n\n\n\n\n\nCombining vectors with rbind() and cbind() rbind() combines vectors by row, while cbind() combines by column. This means that rbind() will stack vectors on top of each other, while cbind() will place them side by side.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Matrix</span>"
    ]
  },
  {
    "objectID": "Matrix_4.html#index-of-matrix",
    "href": "Matrix_4.html#index-of-matrix",
    "title": "4  Matrix",
    "section": "4.2 Index of matrix",
    "text": "4.2 Index of matrix\nJust like vector, you can access specific elements of matrix using index. However, since matrix has two dimensions, you need to specify both row and column index.\nWhen you index, you use matrix[row, column] format.Emptying either means “all of them,” and you can also use range like how we created 1,2,3,4 with 1:4.\n\ntest &lt;- matrix(1:25, nrow=5, ncol=5)\ntest\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    6   11   16   21\n[2,]    2    7   12   17   22\n[3,]    3    8   13   18   23\n[4,]    4    9   14   19   24\n[5,]    5   10   15   20   25\n\n\n\ntest[2, 3]  # Access element at 2nd row, 3rd column\n\n[1] 12\n\n\n\ntest[ , 4]  # Access all rows in 4th column\n\n[1] 16 17 18 19 20\n\n\n\ntest[5, 1:3]  # Access 1st-3rd column in 5th row\n\n[1]  5 10 15\n\n\nThere is special about matrix in R. If you use minus, like [, -2], it means “Don’t display (whatever you decide)”. This means that you can manipulate matrix! Look at example below. Do you notice that 6-10 are missing?\n\ntest[ , -2]  # Access all rows except 2nd column\n\n     [,1] [,2] [,3] [,4]\n[1,]    1   11   16   21\n[2,]    2   12   17   22\n[3,]    3   13   18   23\n[4,]    4   14   19   24\n[5,]    5   15   20   25\n\ntest &lt;- test[ , -2]  # By saving \"test matrix without 2nd column\", you can remove 2nd column from original matrix test\n\nLike how matrix fills in order (like column first, then row), when you remove rows or columns, you can manipulate matrix beyond simply removing specific rows or columns. Look at example below. For example, 1:5 mean “1st to 5th row.” Then what will happen if we do 5:1?\n\ntest[5:1, ]  \n\n     [,1] [,2] [,3] [,4]\n[1,]    5   15   20   25\n[2,]    4   14   19   24\n[3,]    3   13   18   23\n[4,]    2   12   17   22\n[5,]    1   11   16   21\n\n\nBecause we’re displaying test matrix from 5th row to 1st row, the order of rows get reversed! Pause and Think: what would test[order(a[, 2]), ] do?\nLike how we filtered out the matrix, we can manipulate them using logical operations. In this case, it only displays elements that’s TRUE. Check example below.\n\npeople &lt;- c(\"John\", \"Jane\", \"Jim\", \"Jill\", \"Jack\")\nAge &lt;- c(28, 34, 29, 42, 23)\nHeight &lt;- c(175, 160, 180, 165, 170)\n\nInformation &lt;- cbind(people, Age, Height) # Imagine what output it would be!\nInformation[ , c(T,F,T)]  # Display only 1st and 3rd column (those with TRUE)\n\n     people Height\n[1,] \"John\" \"175\" \n[2,] \"Jane\" \"160\" \n[3,] \"Jim\"  \"180\" \n[4,] \"Jill\" \"165\" \n[5,] \"Jack\" \"170\" \n\n\n\nInformation[Information[ ,2] &gt; 30, ]  # Display only rows where Age (2nd column) is greater than 30\n\n     people Age  Height\n[1,] \"Jane\" \"34\" \"160\" \n[2,] \"Jill\" \"42\" \"165\" \n\n\nHowever, there is issue with the structure of matrix when we combine multiple vectors. Let’s say you want to investigate average bloodpressure of a patient\n\n# Data with visiting date, bloodpressure, and patient id\nrecord &lt;- matrix(c(\"2023-01-01\", 120, 123,\n                   \"2023-01-02\", 130, 124,\n                   \"2023-01-01\", 125, 456,\n                   \"2023-01-02\", 135, 456), nrow=4, ncol=3, byrow=TRUE)\nrecord\n\n     [,1]         [,2]  [,3] \n[1,] \"2023-01-01\" \"120\" \"123\"\n[2,] \"2023-01-02\" \"130\" \"124\"\n[3,] \"2023-01-01\" \"125\" \"456\"\n[4,] \"2023-01-02\" \"135\" \"456\"\n\nAvg_BP &lt;- mean(as.numeric(record[, 2]))  # Think, why do we need as.numeric() ?\nAvg_BP\n\n[1] 127.5\n\n\nBut you realized that you forgot the heights of patients, and you create new matrix.\n\n# Data with visiting date, height, bloodpressure, and patient id\nrecord_fix &lt;- matrix(c(\"2023-01-01\", 150, 120, 123, \n                       \"2023-01-02\", 150, 130, 124,\n                       \"2023-01-01\", 150, 125, 456, \n                       \"2023-01-02\", 150, 135, 456), nrow=4, ncol=4, byrow=TRUE)\nAvg_BP &lt;- mean(as.numeric(record_fix[, 2]))  # Run the same code again\nAvg_BP\n\n[1] 150\n\n\nAfter fixing the matrix, running same code that gave us average blood pressure is giving us wrong result! This is because adding new column shifted location of existing information. Then how can we track which information is where? This is where rownames() and colnames() takes place to assign titles to rows and columns.\n\ncolnames(record_fix) &lt;- c(\"Date\", \"Height\", \"BloodPressure\", \"PatientID\")\nrecord_fix\n\n     Date         Height BloodPressure PatientID\n[1,] \"2023-01-01\" \"150\"  \"120\"         \"123\"    \n[2,] \"2023-01-02\" \"150\"  \"130\"         \"124\"    \n[3,] \"2023-01-01\" \"150\"  \"125\"         \"456\"    \n[4,] \"2023-01-02\" \"150\"  \"135\"         \"456\"    \n\n\nNow, we can access information by their names, not by their index. This way, even if we add new information, we can still access existing information without worrying about shifting index.\n\nAvg_BP &lt;- mean(as.numeric(record_fix[ , \"BloodPressure\"]))\nAvg_BP\n\n[1] 127.5\n\n\nGreat fix! By the way, review old matrices like “Information” or m_row, and compare to “record.” Do you notice two have colnames while one doesn’t? This is where creating matrix by combining vectors (rbind, cbind) is better than creating matrix by dividing single vector (how we made record). When you use rbind() and cbind(), they recognize names of vectors, thinking “these values belong under the name of the vector!” As result, functions automatically assign colnames() or rownames() using vector names.\nOne last thing, matrix is 2x2. What if you only give one index like how we did in vector indexing? In matrix, inputing one index means matrix will behave like a vector. So, like how matrix fills by column first and then rows, matrix[i] will return index after scanning column and row order.\n\nlast &lt;- matrix(1:9, nrow=3, ncol=3)\nlast\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\nlast[5] # Since it's 3x3, 5th index will be [2,2]. 1st column (3 elements), and 2nd column's 2nd element. \n\n[1] 5\n\nlast[last &gt; 5]  # Returns all elements greater than 5 as 1-dimensional vector\n\n[1] 6 7 8 9",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Matrix</span>"
    ]
  },
  {
    "objectID": "Matrix_4.html#calculation-of-matrix",
    "href": "Matrix_4.html#calculation-of-matrix",
    "title": "4  Matrix",
    "section": "4.3 Calculation of matrix",
    "text": "4.3 Calculation of matrix\nBefore we get into calculation of matrix, you should know the math behind matrix calculation. Please review concepts regarding matrix, adding/subtracting/multiplying matrices. Others are good to know but optional. Link is here\n\nNow let’s try calculating matrix in R. First, creating two matrices with same dimension.\n\nA &lt;- matrix(1:9, nrow=3, ncol=3)\nB &lt;- matrix(9:1, nrow=3, ncol=3)\nA\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\nB\n\n     [,1] [,2] [,3]\n[1,]    9    6    3\n[2,]    8    5    2\n[3,]    7    4    1\n\n\n\nA + B\n\n     [,1] [,2] [,3]\n[1,]   10   10   10\n[2,]   10   10   10\n[3,]   10   10   10\n\nB - A\n\n     [,1] [,2] [,3]\n[1,]    8    2   -4\n[2,]    6    0   -6\n[3,]    4   -2   -8\n\nA * B\n\n     [,1] [,2] [,3]\n[1,]    9   24   21\n[2,]   16   25   16\n[3,]   21   24    9\n\nA / B\n\n          [,1]      [,2]     [,3]\n[1,] 0.1111111 0.6666667 2.333333\n[2,] 0.2500000 1.0000000 4.000000\n[3,] 0.4285714 1.5000000 9.000000\n\n\nGreat! R is doing element-wise calculation. This means that R is adding/subtracting/multiplying/dividing each element in same position. For example, A[1,1] + B[1,1], A[1,2] + B[1,2], and so on.\nOne question, do matrix follow recycling rule? Try making two matricies with different dimension and adding them. You’ll see the error - R cannot perform calculations that violates fundemental rules of math. However, when you’re using vector and matrix, vectors can be recycled.\n\nC &lt;- c(0, 10, 100)\n\nA + C\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]   12   15   18\n[3,]  103  106  109\n\n\nHowever, we should keep in mind that vector should be shorter than the number of elements in the matrix. If vector is longer, what are we adding leftover vector elements with?",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Matrix</span>"
    ]
  },
  {
    "objectID": "Matrix_4.html#functions-regarding-matrix",
    "href": "Matrix_4.html#functions-regarding-matrix",
    "title": "4  Matrix",
    "section": "4.4 Functions regarding matrix",
    "text": "4.4 Functions regarding matrix\n###nrow(), ncol(), dim()\nHow do we know size of unknown matrix? nrow() and ncol() returns number of rows and columns, while dim() returns both as vector. dim() returns column size first! Don’t get confused with [row, column] in indexing.\n\nm &lt;- matrix(1:12, nrow=3, ncol=4)\nnrow(m)\n\n[1] 3\n\nncol(m)\n\n[1] 4\n\ndim(m)\n\n[1] 3 4\n\n\n\n4.4.1 rownames(), colnames()\nEarlier, we saw how we can assign row names and column names by rownames() &lt;- c(names). However, can we do the opposite? Like, checking names of cols and rows instead of assigning? Yes! Instead of assigning through &lt;-, you can use rownames(matrix) or colnames(matrix) to check names of rows and columns.\n\ncolnames(m) \n\nNULL\n\nrownames(m)\n\nNULL\n\n\nHere, we get Null (empty). Why is that? Look at how m looks like and think about it!\n\n\n4.4.2 t()\nTranspose matrix is matrix with switched rows and columns (for example, 2x3 becomes 3x2). In R, you can do this by t() function.\n\nm\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\nt(m)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n[4,]   10   11   12\n\n\n###Moving between matrix and vector\nSometimes, you may want to convert matrix into vector or vice versa. You can do this by as.vector() or c(). as.vector() unstrings matrix into single line (= vector). And do you remember how giving one input feature in indexing make matrix behave like vector? c() function does the same thing. If you do c(matrix) without telling what else to combine with, c() will combine matrix itself into one string, making it vector.\n\nTestmat &lt;- matrix(1:9, nrow=3, ncol=3)\nas.vector(Testmat)\n\n[1] 1 2 3 4 5 6 7 8 9\n\nc(Testmat)\n\n[1] 1 2 3 4 5 6 7 8 9\n\n\n\n\n4.4.3 Apply()\nOften, we need to perform calculation throughout row or column of the matrix (e.g. finding average height by each person, finding total score by each student). Instead of writing all elements individually, we can use apply() function.\napply() has three main arguments (inputs). X (target), Margin (which direction do you want to apply the function? 1 is row, 2 is column), and Function (work you want to perform)\n\nScores &lt;- matrix(c(90, 85, 88,\n                   78, 92, 80,\n                   85, 87, 90), nrow=3, byrow=TRUE)\ncolnames(Scores) &lt;- c(\"Math\", \"Science\", \"English\")\nScores\n\n     Math Science English\n[1,]   90      85      88\n[2,]   78      92      80\n[3,]   85      87      90\n\n#Let's find average score of each subjects\nmath_avg &lt;- (Scores[1,1] + Scores[2,1] + Scores[3,1]) / 3\nmath_avg\n\n    Math \n84.33333 \n\n#Doing this for each column is annoying. Let's use apply()\nexam_avg &lt;- apply(Scores, 2, mean) # Find mean (function) of matrix (Scores) by column (2)\nexam_avg\n\n    Math  Science  English \n84.33333 88.00000 86.00000",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Matrix</span>"
    ]
  },
  {
    "objectID": "Matrix_4.html#creating-an-array",
    "href": "Matrix_4.html#creating-an-array",
    "title": "4  Matrix",
    "section": "5.1 Creating an array",
    "text": "5.1 Creating an array\nWe can declare by matrix in a similar way to how we declared vectors. 1. Define matricies you want to stack 2. Use array() function to stack them * Remember, dimension should be identical to be able to stack them.\n\nmat1 &lt;- matrix(1:6, nrow=2, ncol=3)\nmat2 &lt;- matrix(7:12, nrow=2, ncol=3)\narr &lt;- array(c(mat1, mat2), dim = c(2, 3, 2)) # 2 rows, 3 columns, 2 layers\narr\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n\n\nUnlike how matrix or vectors were single layer, you’ll see that 3D array has layers, shown as “, , 1” and “, , 2”. Arrays fill data just like matrix. Column first, then rows (next columns), then layers. In the same way, you can index them. Array[row, column, layer]. If you expand it to 4,5,6th dimensions? You just keep adding commas! For example, array[row, column, layer, 4th dimension, 5th dimension]\nIt is difficult to imagine it, so I’ll visualize 3D array we made (arr) below.\n\n\n\n\n\nJust like colnames and rownames in matrix, you can assign names to each dimension using dimnames() function.\n\ndimnames(arr) &lt;- list(\n  Row = c(\"R1\", \"R2\"),\n  Column = c(\"C1\", \"C2\", \"C3\"),\n  Layer = c(\"L1\", \"L2\")\n)\narr\n\n, , Layer = L1\n\n    Column\nRow  C1 C2 C3\n  R1  1  3  5\n  R2  2  4  6\n\n, , Layer = L2\n\n    Column\nRow  C1 C2 C3\n  R1  7  9 11\n  R2  8 10 12\n\n\nNow, you can index using names too!\n\narr[\"R1\", \"C2\", \"L1\"]\n\n[1] 3\n\n\nHowever, there is one thing that you should be careful. Let’s look at the example below\n\narr[1, 2:3, 1:2] # Access 1st row, 2nd-3rd column, all layers\n\n      Layer\nColumn L1 L2\n    C2  3  9\n    C3  5 11\n\n\nWe asked them to display first row, 2nd-3rd column, all layers: 3D data. However, output is 2x2 matrix, a 2D data. Like this, when R can display result in lower dimension, it will do it. If you want to keep the original dimension, use drop = False argument. If you look at the example below, you’ll see that output is seperated into two layers again.\n\narr[1, 2:3, 1:2, drop = FALSE] \n\n, , Layer = L1\n\n    Column\nRow  C2 C3\n  R1  3  5\n\n, , Layer = L2\n\n    Column\nRow  C2 C3\n  R1  9 11",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Matrix</span>"
    ]
  },
  {
    "objectID": "Matrix_4.html#calculation-of-array",
    "href": "Matrix_4.html#calculation-of-array",
    "title": "4  Matrix",
    "section": "5.2 Calculation of Array",
    "text": "5.2 Calculation of Array\nOmitted. Everything is same as Matrix calculation.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Matrix</span>"
    ]
  },
  {
    "objectID": "Matrix_4.html#advanced-caluclation",
    "href": "Matrix_4.html#advanced-caluclation",
    "title": "4  Matrix",
    "section": "5.3 Advanced caluclation",
    "text": "5.3 Advanced caluclation\n\n5.3.1 Solving equations with matrix\nMatrix and Array can be used in a lot of places. Due to its compact representation of high dimnesional data, we often use matrix to represent equations with multiple dimension. For example,\n3x + 2y = 5 4x + 6y = 12\ncan be written as [3, 2, 5]; [4, 6,12] (; is used to seperate rows). So, we condensed multiple equations into one 2x3 matrix. This also means that we can use matrix to solve complex equations.\nUsing the matrix above as example, we have two parts: variables (x and y), and constants (5 and 12). We can separate them into two matrices:\n\nA &lt;- matrix(c(3, 2,\n              4, 6), nrow=2, byrow=TRUE) # Coefficient matrix\nB &lt;- matrix(c(5, 12), nrow=2) # Constant matrix\ncolnames(A) &lt;- c(\"x\", \"y\")\n\nNow, you can just use solve() to find values of x and y!\n\nsolution &lt;- solve(A, B)\nsolution\n\n  [,1]\nx  0.6\ny  1.6\n\n\n\n\n5.3.2 Eigenvalues and Eigenvectors\nThis is core concept of linear algebra, which will help you understand more advanced machine learning algorithms. However, it’s difficult to understand without proper math background, so we’ll come back to this later. For now, watch this playlist to get introduction to linear algebra. I highly recommend this.\nLink: Linear Algebra by 3Blue1Brown",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Matrix</span>"
    ]
  },
  {
    "objectID": "List_5.html",
    "href": "List_5.html",
    "title": "5  List",
    "section": "",
    "text": "5.1 Object and Class\nSo far we looked at vector, matrix, and array. However, one limitation was that all elements in them need to be same data type. Revisit “Information” matrix where we stored patient’s visit date, blood pressure, and patient ID. All elements were character type (“text”) despite of bp/ID being number because “Date” was in text format.\nBut why is that really the case? Why can we declare vectors with text, numbers, or logic, but not two at the same time?\nTo answer this, we need to understand what object and type are.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>List</span>"
    ]
  },
  {
    "objectID": "List_5.html#object-and-class",
    "href": "List_5.html#object-and-class",
    "title": "5  List",
    "section": "",
    "text": "5.1.1 What is Object?\nSingle component we decide to store was called variable. Then how about some kind of produces like vectors? Single unit of whatever data that R can recall, like vectors, matrix, and functions, are called “Objects.”\nIn stored data’s perspective, Objects are divded into two types. “Atomic” and “Generic (or List)” List, we’ll talk about it later.\nAtomic object is what we’ve been reviewing: A vector, data we can store with single data type. Some examples are vectored made out of logical, integer, character, float (double), complex, etc.\n\n5.1.1.1 Characteristics of Object\nAll object has two intrinsic characteristics: Type and Length.\nType is literally type of data we discussed in Chapter 2. Nothing more to say. Throughout previous chapters, we talked about how to declare the vectors. However, we never talked about how to check data type of random vector. We use function called typeof() for that.\n\na &lt;- c(T, F, T, T); typeof(a)\n\n[1] \"logical\"\n\nb &lt;- c(1.2, 0.3, 3.5, 2.3); typeof(b)\n\n[1] \"double\"\n\n\nLength is another characteristic of object. It tells how many elements are in the object. For example, vector with 4 elements will have length of 4. We can check length of object with length() function.\n\nlength(a)\n\n[1] 4\n\n\nIntrinsic characteristics are intrinsic because they can’t be changed once object is created. For example, if we create a vector with character type, we can’t change it to numeric type unless we manually code it to be so.\nBut Question here:\n\na &lt;- c(1, 2, 3, 4)\nb &lt;- matrix(c(1:4), nrow = 2, ncol = 2)\na\n\n[1] 1 2 3 4\n\nb\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n\nConsider two following data. Both have same length (4), and same data tpye (int). There intrinsic characteristics are same, but they look different (one is 1D vector, another is 2D matrix). How do R distinguish different objects with identical intrinsic characteristics?\n\n\n\n5.1.2 Class\nClass solves the question. Class is an “atrribute” that you can assign to the object to tell R how to treat the object.\nFor example, vector “a” and matrix “b” both have same length (4) and same data type (int). However, R treats them differently because their class is different. Vector “a” is stored with class “numeric” while matrix “b” has class “matrix.” We can check class of objects by class().\n\nclass(a) # This was vector\n\n[1] \"numeric\"\n\nclass(b) # This was matrix\n\n[1] \"matrix\" \"array\" \n\n\n\n\n5.1.3 Attributes\nAnother question is, “Okay, now we know that it’s the class that differentiate vector and matrix. But, how do R know the matrix is 2x2?, not 4x1?”\nWhen we declare objects, R saves all the accessory information (people call it meta data. It’s anything besides intrinsic characteristics, like class) as “Attributes.” You can check all attributes using attributes() function. Let’s try it.\n\nattributes(a)\n\nNULL\n\nattributes(b)\n\n$dim\n[1] 2 2\n\n\nAs you can see, vector “a” has no attributes, meaning that it’s just a simple 1D structure. However, matrix “b” has dimension of 2,2 which means 2x2. This dimension attribute ($dim) tells R that this object is 2D structure with 2 rows and 2 columns.\n\n5.1.3.1 Editing attributes\nEarlier, we said that intrinsic characteristics can’t be changed once object is created. However, attributes can be changed after creation. Let’s try changing dimension attribute of vector “a” to make it 2x2 matrix. We use attr() function to edit them.\n\na\n\n[1] 1 2 3 4\n\nattr(a, \"dim\") \n\nNULL\n\n# Like rownames(), function(target, detail) displays detail of the target. Here, we're asking to display the dim (dimension) attribute of a. Since a is simple vector, it'll be NULL (nothing).\n\nattr(a, \"dim\") &lt;- c(2, 2) # Like assigning rownames, now \"&lt;-\" assigns (2,2) to dim attribute of a.\na # Now a is 2x2 matrix!\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\nclass(a) # And class of a is now matrix!\n\n[1] \"matrix\" \"array\" \n\n\nThere are many attributes, such as dimnames() (name of each dimension), names() (name of each element in 1D structure), etc. You can check all attributes using attributes() function. You can look them up and play with it!",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>List</span>"
    ]
  },
  {
    "objectID": "List_5.html#summary-list",
    "href": "List_5.html#summary-list",
    "title": "5  List",
    "section": "5.2 Summary & List",
    "text": "5.2 Summary & List\nSo what was the answer to the question at the beginning of “Object and Class,” what was the point of whole section about them?\nConsider that intrinsic characteristics are saved and doesn’t change when objects are declared. This also means that different type of data are saved and recalled through different pathway. For example, integer vector are stored where only integer exists. In the same way, method that vector is loaded for calculation is also something only integer can understand. Therefore, vector/matrix/array can hold only single data type.\nHowever, sometimes we need to save multiple data type like patient information vector (visiting date in character, vital signs in numeric). This is where “Generic (because it’s not atomic)” object, or “List” comes in. List is special object that can hold multiple data type at the same time. Each element in list can be different data type, and even different structure (vector, matrix, array, another list, etc)!\nEach element in the list is called “Component.”",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>List</span>"
    ]
  },
  {
    "objectID": "List_5.html#creating-a-list",
    "href": "List_5.html#creating-a-list",
    "title": "5  List",
    "section": "5.3 Creating a List",
    "text": "5.3 Creating a List\nJust like atomic objects, list are declared through list() function in two ways: unnamed list and named list.\n\nUnnamed list: list(Compoenent1, Component2, Component3))\nNamed list: list(Name1 = Component1, Name2 = Component2, Name3 = Component3)\n\nLet’s try an example.\n\nmy_list &lt;- list(Name = c(\"Patient1\", \"Patient2\", \"Patient3\"), #Component 1\n                Age =  c(30, 45, 28), #Component 2\n                Diabetic = c(F, T, F), #Component 3\n                Visit.Date = matrix(c(\"2023-12-1\",\n                                     \"2024-2-16\",\n                                     \"2025-3-20\"),\n                                     nrow = 3, byrow = TRUE) #Component 4\n)\n\nprint(my_list)\n\n$Name\n[1] \"Patient1\" \"Patient2\" \"Patient3\"\n\n$Age\n[1] 30 45 28\n\n$Diabetic\n[1] FALSE  TRUE FALSE\n\n$Visit.Date\n     [,1]       \n[1,] \"2023-12-1\"\n[2,] \"2024-2-16\"\n[3,] \"2025-3-20\"\n\n\nNow you see all Character, Numeric, Logical, and even Matrix are stored in single object. Here, we have each components named like “Name,” but it will show up as [[1]], [[2]], etc., if they’re unnamed.\nOne important thing to remember while creating a list is that component’s name isn’t automatically assigned like how creating vector using cbind() named columns whether you name them or not.\n\nvar1 = c(3,5)\nvar2 = c(7,9)\n\ncbind(var1, var2) # Columns are named var1 and var2 automatically\n\n     var1 var2\n[1,]    3    7\n[2,]    5    9\n\n\n\nlist(var1, var2)\n\n[[1]]\n[1] 3 5\n\n[[2]]\n[1] 7 9\n\n\nSo like the my_list, you must manually assign names to list, like variable1 = var1.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>List</span>"
    ]
  },
  {
    "objectID": "List_5.html#indexing-list",
    "href": "List_5.html#indexing-list",
    "title": "5  List",
    "section": "5.4 Indexing List",
    "text": "5.4 Indexing List\nUnlike vectors, List use different notation for index: listname[[index]]. Check the exmaple below:\n\nclass(my_list[1])\n\n[1] \"list\"\n\n\n\nclass(my_list[[1]])\n\n[1] \"character\"\n\n\nOne is list, and another is character. What’s the difference? To remember the difference, think of level of information you need to call.\n\nSingle bracket [ ]: Index of one level deeper (like calling component in vector X). So In list, [] will call entire “Component” itself. For example, my_list[i] will print entire i-th component. However, this is still a list object because list had two factors: Name and value.\n\n\nmy_list[c(1, 2)] # Calls entire first and second component\n\n$Name\n[1] \"Patient1\" \"Patient2\" \"Patient3\"\n\n$Age\n[1] 30 45 28\n\n\n\nDouble bracket [[ ]]: Index of two level deeper. So In list, [[]] will call specific “element” inside the component. For example, my_list[[i]] will return contents in i-th component. This time, this is vector since it only prints out values without name. Check the example, can you spot the difference?\n\n\nmy_list[[1]] # Calls elements inside first component (Patient1, Patient2, Patient3)\n\n[1] \"Patient1\" \"Patient2\" \"Patient3\"\n\n\n\nmy_list[1]\n\n$Name\n[1] \"Patient1\" \"Patient2\" \"Patient3\"\n\n\nImportant thing you must remember is that [] recalls component as list (list with 1 component), while [[]] recalls component as vector. So, for example, my_list[1][2] won’t work since my_list[1] has only first element (2nd element of my_list[1] is non-existent). However, my_list[[1]][2] will work since my_list[[1]] is vector with 3 elements.\n\nmy_list[1][2] # As you can see, it prints out NULL.\n\n$&lt;NA&gt;\nNULL\n\n\n\nmy_list[[1]][2] # Calls 2nd element in first component (Patient2\n\n[1] \"Patient2\"\n\n\nLike vectors, you can also use name to call specific component/element. A lot of times, people use its alternatives, $, to call component by name. It’s easier to type. There output is same!\n\nmy_list[[\"Age\"]]\n\n[1] 30 45 28\n\nmy_list$Age\n\n[1] 30 45 28\n\n\nAlso, like vectors, you can recall elements in component by adding another index.\n\nmy_list$Name[2:3] # Calls 2nd and 3rd element in \"Name\" component\n\n[1] \"Patient2\" \"Patient3\"\n\n\nOne special point about indexing an list in R is that you can call component by portion of name as long as it’s unique. Let’s try it.\n\nmy_list$Visit\n\n     [,1]       \n[1,] \"2023-12-1\"\n[2,] \"2024-2-16\"\n[3,] \"2025-3-20\"\n\n\nEven though name of that component was “Visit.Date,” R was able to recall it because no other component started with “Visit.” However, be careful when you have multiple components with similar names.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>List</span>"
    ]
  },
  {
    "objectID": "List_5.html#editing-list",
    "href": "List_5.html#editing-list",
    "title": "5  List",
    "section": "5.5 Editing List",
    "text": "5.5 Editing List\nLet’s say you created a list. However, what if you need to change information to update record? Let’s look at how we can do it.\n\n5.5.1 Adding Component\nYou can add component to list by simply adding a new component to the list.\n\nmy_list$Height\n\nNULL\n\n\nRight now, my_lit doesn’t have “height component” that it returns NULL. Let’s add it.\n\nmy_list$Height &lt;- c(170, 180, 160) # Adding Height component\nmy_list\n\n$Name\n[1] \"Patient1\" \"Patient2\" \"Patient3\"\n\n$Age\n[1] 30 45 28\n\n$Diabetic\n[1] FALSE  TRUE FALSE\n\n$Visit.Date\n     [,1]       \n[1,] \"2023-12-1\"\n[2,] \"2024-2-16\"\n[3,] \"2025-3-20\"\n\n$Height\n[1] 170 180 160\n\n\nWow! By adding Height component, now we see that list is extended.However, think about this: what will happen if we add componenet to way far back of the last element?\n\nmy_list[[7]] &lt;- c(\"A+\", \"B\", \"O-\") # Adding Blood Type component at 6th index. Our Last component was [[5]]\nmy_list[5:7]\n\n$Height\n[1] 170 180 160\n\n[[2]]\nNULL\n\n[[3]]\n[1] \"A+\" \"B\"  \"O-\"\n\n\nAs you can see, we skipped 6th component slot and added bloodtype to 7th. R will automatically fill skipped componenet in the list with NULL.\n\n\n5.5.2 Editing Component\nIn the same way with adding the component, we can edit elements within the component by overwriting existing component (assigning new content to desired index).\n\nmy_list$Height &lt;- c(4,5,6) # Changing Height into 4, 5, 6\nmy_list$Height\n\n[1] 4 5 6\n\nmy_list[[5]] &lt;- c(150, 160, 170) # You can also edit using number index\nmy_list$Height\n\n[1] 150 160 170\n\n\nDo you remember how we could recall partial list (component as list) using []? In the same way, you can edit multiple components of list using []. However, remember that assignment (new edits) must be list, since list[] acts as a list, not vector.\n\nmy_list[1:2]\n\n$Name\n[1] \"Patient1\" \"Patient2\" \"Patient3\"\n\n$Age\n[1] 30 45 28\n\nmy_list[1:2] &lt;- list(Name = c(\"NewPatient1\", \"NewPatient2\", \"NewPatient3\"),\n                             Age = c(35, 50, 40)) # Editing Name and Age component at once\nmy_list[1:2]\n\n$Name\n[1] \"NewPatient1\" \"NewPatient2\" \"NewPatient3\"\n\n$Age\n[1] 35 50 40\n\n\nNow, name and age of patients are changed at once!\nOne thing to be careful is that recycling rule applies in the list too. So if I try to add a component with different length, R will recycle the values.\n\nmy_list[9:11] &lt;- list(c(\"Text\"), 12) # Adding Weight component with length\n\nWarning in my_list[9:11] &lt;- list(c(\"Text\"), 12): number of items to replace is\nnot a multiple of replacement length\n\nmy_list[9:11] # Now, you'll see \"Text\" twice because of recycling\n\n[[1]]\n[1] \"Text\"\n\n[[2]]\n[1] 12\n\n[[3]]\n[1] \"Text\"\n\n\n\n\n5.5.3 Removing Component\nRecall how skipping component resulted in Null, empty. We can use this to remove component from the list! Simpy assign Null to the component you want to remove. It’s like editing a list, but with empty component.\n\nmy_list[8:11] &lt;- NULL # Removing my_list[9:11] we just added. But think, why [8:11], not[9:11]?\nmy_list[[7]] &lt;- NULL # Removing blood type component\n\nNow, try calling blood type by my_list[[7]]. It will return error since it doesn’t exist anymore.\n\n\n5.5.4 Vector to list, list to Vector\nRecall how we could change data type among vectors, like number to character? In the same way, we can convert vector to list, and list to vector.\n\nTest_Vector &lt;- c(10, 20, 30, 40)\nTest_List &lt;- as.list(Test_Vector) # Converting vector to list\nTest_List # List to vector will be as.vector()\n\n[[1]]\n[1] 10\n\n[[2]]\n[1] 20\n\n[[3]]\n[1] 30\n\n[[4]]\n[1] 40\n\n\nAlso, we can connect different lists using c() like vectors.\n\nAnother_List &lt;- list(\"Text1\", \"Text2\")\nCombined_List &lt;- c(Test_List, Another_List)\nCombined_List\n\n[[1]]\n[1] 10\n\n[[2]]\n[1] 20\n\n[[3]]\n[1] 30\n\n[[4]]\n[1] 40\n\n[[5]]\n[1] \"Text1\"\n\n[[6]]\n[1] \"Text2\"\n\n\nOne thing to be careful is the hierarchy of list. When you use c(), you’re putting two vectors next to each other (equally). This results a list with single layer (component1, componenet2, etc, like example above). However, if you create a list by combining other lists, combined list will be compoenent of new list, creating multiple layers.\n\nCombined_List2 &lt;- list(Sublist1 = Test_List, Sublist2 = Another_List)\nCombined_List2\n\n$Sublist1\n$Sublist1[[1]]\n[1] 10\n\n$Sublist1[[2]]\n[1] 20\n\n$Sublist1[[3]]\n[1] 30\n\n$Sublist1[[4]]\n[1] 40\n\n\n$Sublist2\n$Sublist2[[1]]\n[1] \"Text1\"\n\n$Sublist2[[2]]\n[1] \"Text2\"\n\n\nNow, you’ll see that both Test_list and Another_List became components under name of Sublist1, and Sublist2, respectively (2 layered list). Then, could we transform multi-layered list into vector? Yes, we can use unlist() function for that.\n\nunlist(Combined_List2)\n\nSublist11 Sublist12 Sublist13 Sublist14 Sublist21 Sublist22 \n     \"10\"      \"20\"      \"30\"      \"40\"   \"Text1\"   \"Text2\"",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>List</span>"
    ]
  },
  {
    "objectID": "List_5.html#functions-with-list",
    "href": "List_5.html#functions-with-list",
    "title": "5  List",
    "section": "5.6 Functions with List",
    "text": "5.6 Functions with List\nMany functions we learned can be applied to list. However, apply() doesn’t work on list because list is a generic object with different components, while apply() requires same data type as it perform same work throughout the object.\n\n5.6.1 lapply()\nlapply works by apply(list, function). Let’s look at the example.\n\nSample1 &lt;- list(A = c(1,2,3), B = c(4,5,6), C = c(7,8,9))\nSample1\n\n$A\n[1] 1 2 3\n\n$B\n[1] 4 5 6\n\n$C\n[1] 7 8 9\n\n\nIf we want to find mean of each component, using mean() requires us to calculate through three lines of code (mean() per component). Using, lapply does the same in single line.\n\nlapply(Sample1, mean)\n\n$A\n[1] 2\n\n$B\n[1] 5\n\n$C\n[1] 8\n\n\nHere, remember that lapply() applies function to each componenet and return the result in identical structure to the input (so list in this case).\n\n\n5.6.2 sapply()\nMany times, we want the calculation to return in simplified structure like vector so that we don’t have to index list every time (which is more complex and time consuming). sapply() does the same thing with lapply(), but return the result in vector or matrix.\n\nsapply(Sample1, mean)\n\nA B C \n2 5 8 \n\nsapply(Sample1, range)\n\n     A B C\n[1,] 1 4 7\n[2,] 3 6 9\n\n\nNow, instead of multi components from lapply ($A, $B, $C), we have single vector with three elements. This is easier to use in many cases. If result requires multiple rows/columns, like range(), output will be matrix.\n\n\n5.6.3 mapply()\nSo lapply() and sapply() apply function to single list. But what if we have multiple lists and want to apply function to them at once? mapply() is the answer. mapply() works by mapply(function, list1, list2, …). Let’s look at example.\n\nmList &lt;- list(A = c(1,2,3), B = c(4,5,6), C = c(7,8,9))\nmList2 &lt;- list(D = c(10, 11, 12, 13), E = c(14, 15), F = c(16, 17, 18))\n\nmapply(c, mList, mList2) # Perform c() of each component in mList and mList2\n\n$A\n[1]  1  2  3 10 11 12 13\n\n$B\n[1]  4  5  6 14 15\n\n$C\n[1]  7  8  9 16 17 18\n\n\nAs you can see, each component in mList and mList2 are combined using c(). Two points to notice here: 1. mapply() is order sensitive. If you put mList2 first, mList2 will be at the front of the result. 2. When combining components with different names, names of first list are prioritized (Here, six components are combined into three components. Since A, B, C are from first list, they’re kept as names). 3. mapply() performs dimension reduction\nWhat do we mean by #3? Look at the output below:\n\nmList3 &lt;- list(G = c(10, 11, 12), H = c(13, 14, 15), I = c(16, 17, 18))\nmapply(c, mList, mList3)\n\n      A  B  C\n[1,]  1  4  7\n[2,]  2  5  8\n[3,]  3  6  9\n[4,] 10 13 16\n[5,] 11 14 17\n[6,] 12 15 18\n\n\nHere, we have a single matrix instead of list with three components. Why is this? Review the length of each component.\n\nmList and mList2: Since mList and mList2’s component pairs (A/D, B/E, C/F) had different lengths, mapply() is required to print output as seperate components: a list.\nmList and mList3: However, in mList and mList3, all componenets (A/G, B/H, C/I) had same length (3). Therefore, mapply() was able to combine them into single matrix instead of list with three components, reducing the dimension.\n\nLike this, mapply() will try to be useful and print most simplified structure possible.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>List</span>"
    ]
  },
  {
    "objectID": "List_5.html#closing",
    "href": "List_5.html#closing",
    "title": "5  List",
    "section": "5.7 Closing",
    "text": "5.7 Closing\nList, which combines multiple data types into single object, is absolute must-know concept in R as many real world data mixes data types (like title and values). Also, this concept of list will be foundation of the highlight of data structure, a dataframe (we’ll cover this in next chapter). Then, see you in next chapter!",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>List</span>"
    ]
  }
]