[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R Guide",
    "section": "",
    "text": "Welcome to “Introduction to R”\nHere, you will learn how to use R for data analysis. Try practice questions, and feel free to contact me anything you have questions.",
    "crumbs": [
      "Welcome to \"Introduction to R\""
    ]
  },
  {
    "objectID": "Structure_of_R_Studio_1.html",
    "href": "Structure_of_R_Studio_1.html",
    "title": "1  Structure of R Studio",
    "section": "",
    "text": "1.1 Creating a Project\nR is a programming language. R Studio is a UI that helps you write, run, and organize your R code. Let’s explore how R Studio looks and what each section does.\nWhen we write codes and save data, it’s important to keep everything organized so that R can remember where things were saved. To tell R Studio where to save and find your files, we use project. It’s like a home for your codes and data.\nLet’s make a new project.\nCongrats! You just made your first project in R. Now let’s start exploring what features are there in R Studio.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Structure of R Studio</span>"
    ]
  },
  {
    "objectID": "Structure_of_R_Studio_1.html#creating-a-project",
    "href": "Structure_of_R_Studio_1.html#creating-a-project",
    "title": "1  Structure of R Studio",
    "section": "",
    "text": "Click “File -&gt; New Project -&gt; New Directory -&gt; New Project”\nChoose location of folder you want to be, a good name, and click “Create Project”",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Structure of R Studio</span>"
    ]
  },
  {
    "objectID": "Structure_of_R_Studio_1.html#ui-of-r-studio",
    "href": "Structure_of_R_Studio_1.html#ui-of-r-studio",
    "title": "1  Structure of R Studio",
    "section": "1.2 UI of R Studio",
    "text": "1.2 UI of R Studio\nOn the main page of R Studio, you’ll see 4 main sections.\n\n1 – Script Editor: This is where you write and save your code.\n2 – Console: It’s a communication window between you and the computer. You can give him commands to execute, and console will show you what it’s doing.\n3 – Environment: You’ll work with countless variables. This section shows what variables you’ve saved as you run your code.\n4 – Directories: Sometimes you need to load data or files for your code. This section shows which files are in your working folder. Default is folder where your project is.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Structure of R Studio</span>"
    ]
  },
  {
    "objectID": "Structure_of_R_Studio_1.html#using-console",
    "href": "Structure_of_R_Studio_1.html#using-console",
    "title": "1  Structure of R Studio",
    "section": "1.3 Using Console",
    "text": "1.3 Using Console\nSo Console is where actual works are done. Let’s try using it. Input 1 + 1 and press enter. You’ll see it’s printing 2, the result of what you asked R to calculate.\n\nHowever, Console is one-time-communicator. It can’t remember anything you say or R executes, making you to retype everything to do same job. This gets annoying fast, especially if your code gets long. How can we make this easy? We’ll figure it out in next the next section.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Structure of R Studio</span>"
    ]
  },
  {
    "objectID": "Structure_of_R_Studio_1.html#creating-a-script",
    "href": "Structure_of_R_Studio_1.html#creating-a-script",
    "title": "1  Structure of R Studio",
    "section": "1.4 Creating a script",
    "text": "1.4 Creating a script\nScript is a file that saves your code so that you don’t have to rewrite same thing every time. Let’s make a script. There are two ways to create a script.\n\nScript and Quarto Document are most common files used to save the codes. Difference between to are what the default text is.\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nScript (Talking to computer)\nPlain texts are considered as code, and you need to use special characters to insert “comments.” It’s for purely performing code it’s written.\n\n\nQuarto Document (Talking to human)\nPlain texts are considered as text, and you need to insert “Chunks” to tell R Studio ‘These are codes I want to run.’ You can export Quarto Doc as beautiful report, which Script can’t.\n\n\n\nThis year, we’ll use Quarto Doc as we need to create reports and share codes to others.\nCreate Quarto Doc. You can use whatever title and Author name you want. Leave other options as it is.\n\n1 – # in the doc indicates the title. The more # you put, the smaller the text size gets. # (biggest) -&gt; ####(Smallest)\n2 – Area that wrapped with {r} and is called “Chunk,” where codes you want to run goes. # in the chunks indicates comment, which will not get executed.\n3 – When you click Run, you’ll see which part of doc you want to execute. If you click specific chunk and “Run Current Chunk,” only clicked chunk will be executed. This is one advantage of Quarto doc too.\nNow, save your quarto doc and Render. You’ll see that (Title).html file is created in your directory (1-&gt;2-&gt;3 marked in the picture). Congrats! You just created your first report using R. When you open the file, you’ll see how quarto doc became visually pretty and clear.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Structure of R Studio</span>"
    ]
  },
  {
    "objectID": "Variables_Calculations_2.html",
    "href": "Variables_Calculations_2.html",
    "title": "2  Data Types and Variables",
    "section": "",
    "text": "2.1 Data Types\nNow, let’s talk about how data are saved in R. R classifies data into four categories: Number, Text, Boolean, Special.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data Types and Variables</span>"
    ]
  },
  {
    "objectID": "Variables_Calculations_2.html#data-types",
    "href": "Variables_Calculations_2.html#data-types",
    "title": "2  Data Types and Variables",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nNumber\nAny numbers. They’re classified into two categories.\nInteger – Type of number WITHOUT decimals.\nE.g.) 1, 10, 100\n\nFloat – Type of number WITH decimals.\nE.g) 1.24, 2.00 (Not int because of “.00”!)\n\n\nText\nAnything you put into “ “, regardless of what’s inside.\nE.g) “Hi”, “121”\n\n\nBoolean\nA logic data. It’s either “True” or “False”\n\n\nSpecial\nValues that cannot be specified\nNull – Empty value without determined data type (Number/Text/Boolean)\nNA – Missing value. Known data type but nothing inside.\nNaN – Unable to mathematically define. E.g.) Saving “Hi” as int/float\n\ninf – Yes, infinite number. They’re under special characters!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data Types and Variables</span>"
    ]
  },
  {
    "objectID": "Variables_Calculations_2.html#variables",
    "href": "Variables_Calculations_2.html#variables",
    "title": "2  Data Types and Variables",
    "section": "2.2 Variables",
    "text": "2.2 Variables\nNow we know that there are multiple types of data. But how do we tell R to remember them? That’s where variables come in! Variables are names that store data values.\nYou can declare a variable by using the assignment operator ‘&lt;-’ or ‘=’.\n\nTest1 &lt;- 3\nTest2 = 4\n\nOnce you declare the variable, you’ll see them in the Environment tab. Also, you’ll be able to call them by simply typing their names.\n\nTest1\n\n[1] 3\n\nTest2\n\n[1] 4\n\n\nIf it’s not working, it’s probably due to variable names. There’re specific rules in naming - First character must be dot(.) or letter. It cannot be number or special character. Second character and later can be anything - You cannot use other function’s name as variable name (sum, mean, etc. We’ll cover functions as we go on) - Variable names are case-sensitive. “test” and “Test” are different variables. - Avoid using spaces in variable names. Use dot(.) or underscore(_) instead. E.g.) my.variable, my_variable",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data Types and Variables</span>"
    ]
  },
  {
    "objectID": "Variables_Calculations_2.html#simple-calculations",
    "href": "Variables_Calculations_2.html#simple-calculations",
    "title": "2  Data Types and Variables",
    "section": "2.3 Simple Calculations",
    "text": "2.3 Simple Calculations\nHere, we’ll review basic operators in program language.\n\n\n\nType\nOperation\n\n\n\n\nAddition\n+\n\n\nSubtraction\n-\n\n\nMultiplication\n*\n\n\nRemainder\n%\n\n\nExponents\n/\n\n\n\nTry some on the script you made! Also, you can use variables in calculations.\n\nTest1 + Test2\n\n[1] 7\n\n\nThere are multiple functions that will make calculations easy\n\n\n\n\n\n\n\nOperation\nDescription\n\n\nceiling(x)\nRound x up as “int”\nE.g.) 3.4 (float) becomes 3 (int)\n\n\nfloor(x)\nRound x down as “int”\n\n\ntrunc(x)\nDrop decimals as “float”\nE.g.) 3.4 (float) becomes 3.0 (float)\n\n\nround(x, digits = n)\nRound x as “float” at nth decimal place.\ndefault (If you omit “digits =n”) is to round at ones place.\n\n\nsqrt(x)\n\\(\\sqrt{x}\\)\n\n\nexp(x)\n\\(e^x\\)\n\n\nlog(x, base = n)\n\\(\\log_{n}(x)\\). Default is base with n = e\n\n\nsin(x), cos(x), etc.\nTrig functions!\n\n\nFactorial(n)\nn! = 1 x 2 x 3 x … x n\n\n\nOthers\nThere are many other function!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data Types and Variables</span>"
    ]
  },
  {
    "objectID": "Variables_Calculations_2.html#logical-calculations",
    "href": "Variables_Calculations_2.html#logical-calculations",
    "title": "2  Data Types and Variables",
    "section": "2.4 Logical Calculations",
    "text": "2.4 Logical Calculations\nSometimes you need more than simple calculations, such as “which number is bigger?” Return values of logical calculations are Boolean (True/False).\n\n\n\nType\nOperation\n\n\n\n\nComparison\n&lt;, &gt;, &lt;=, &gt;=\n\n\nEqual\n==\n\n\nNot Equal\n!=\n\n\nOr\n|\n\n\nAnd\n&",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data Types and Variables</span>"
    ]
  },
  {
    "objectID": "Vectors_3.html",
    "href": "Vectors_3.html",
    "title": "3  Vectors",
    "section": "",
    "text": "3.1 Vectors with Numbers\nLast chapter, we reviewed what variables are. Imagine we’re storing heights of 50 students. Declaring 50 variables like “Height1”, “Height2”, …, “Height50” takes forever. Instead, we can use “vector” to store multiple values in a single variable.\nVector is a 1-dimensional sequence of “same type” of data. For example, vector with int can only store int values. Length of Vector is equal to number of values stored in the vector.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "Vectors_3.html#vectors-with-numbers",
    "href": "Vectors_3.html#vectors-with-numbers",
    "title": "3  Vectors",
    "section": "",
    "text": "3.1.1 Ways to create vectors\n\ny &lt;- c(2, 4, 6, 8, 10)\ny\n\n[1]  2  4  6  8 10\n\n\nAgain, vector must be same data type. For example, if you create one with mix of int and float, all values will be float. Why? because all int can be float by adding “.0” but float cannot be int without losing data. Let’s see an example.\n\nx &lt;- c(1,3,5,7,9.2)\nx\n\n[1] 1.0 3.0 5.0 7.0 9.2\n\n\nRecall c() meant to “connect.” This means you can connect multiple vectors into one as long as they match data type.\n\nz &lt;- c(x, y)\nz\n\n [1]  1.0  3.0  5.0  7.0  9.2  2.0  4.0  6.0  8.0 10.0\n\n\nQuestion: What will happen if we flip the order of element? As you can see below, resulting order of elements in the vector also changes.\n\nz &lt;- c(y, x)\nz\n\n [1]  2.0  4.0  6.0  8.0 10.0  1.0  3.0  5.0  7.0  9.2\n\n\nNow we learned how to create vectors with number. But what if we want to label something and need 1 to 100? Typing them manually will take some time. Instead, there’s a short cut to create continuous numbers with “:” operator. There there two points to remember when using :.\n\nIt has fixed increment of 1.\nIt follows the order from the left to the right. Check the example below.\n\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n10:1\n\n [1] 10  9  8  7  6  5  4  3  2  1\n\n0.2:3\n\n[1] 0.2 1.2 2.2\n\n\nWhat if you want to create vector with different increment? You can use seq() function. It has three main arguments - from, to, by. “from” is where the sequence starts, “to” is where it ends, and “by” is the increment.\n\nseq(1, 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(1, 10, by=2)\n\n[1] 1 3 5 7 9\n\nseq(length=5, from=1, by=2)\n\n[1] 1 3 5 7 9\n\n\nIf you want to create vector with repeated values, you can use rep() function. It has two main arguments - “x” and “times”. “x” is the value you want to repeat, and “times” is how many times you want to repeat it.\n\nrep(5, times=4)\n\n[1] 5 5 5 5\n\n\n\n\n3.1.2 Calculations with Vectors\n\nElement wise operation Just like how we perform calculations with single numbers, we can do the same with vectors. One strong advantage of R is that it’s one of rare programming languages that can perform “vectorized” calculations. This means you can perform calculations using same position of different vectors without complex logics. Let’s perform example calculation using vectors we created.\n\n\nx &lt;- seq(0, 40, by = 10)\ny &lt;- c(1:5)\n\nx + y\n\n[1]  1 12 23 34 45\n\nx * y\n\n[1]   0  20  60 120 200\n\n\n\n\n\n\n\n\nRecycling rule What if the length of vectors are different? In this case, R will recycle the shorter vector until it matches the length of longer vector. Check the example below.\n\n\nz &lt;- c(rep(x, times=2), 50)\nz + y\n\nWarning in z + y: 두 객체의 길이가 서로 배수관계에 있지 않습니다\n\n\n [1]  1 12 23 34 45  1 12 23 34 45 51\n\n\nAs you can see, addition is performed even though length of two vectors didn’t match. The warning sign is indicating that length’s are not multiple of each other, so it shows what we mean by “recycle until it matches the length.” If it’s difficult to grasp, there’s a visualization below.\n\n\n\n\n\n\n\n3.1.3 Functions helpful for numeric vectors\nThere are many functions that can be used with numeric vectors. Here are some of the most commonly used ones. While you might not end up not using them all, try them out and see which ones are useful for you!\n\n\n\n\n\n\n\nOperation\nDiscription\n\n\n\n\nlength(x)\nReturn length of the vector\n\n\nsum(x)\nReturn sum of all elements in the vector\n\n\nmean(x)\nReturn average of all elements\n\n\nmedian(x)\nReturn median of all elements\n\n\nvar(x)\nReturn variance of all elements\n\n\nsd(x)\nReturn standard deviation of all elements\n\n\nmax(x)\nmin(x)\nrange(x)\nReturn highest number in the vector\nReturn lowest number in the vector\nReturn the range (highest and lowest) number\n\n\nrank(x)\nReturn the “ranking” of each element from smallest to biggest\n\n\nsort(x)\nReorganize vector from smallest to biggest elements\n\n\norder(x)\nReturn index of smallest to biggest element’s location\n\n\nwhich.max(x)\nwhich.min(x)\nReturn the highest number’s index\nReturn the lowest number’s index\n\n\nwhich(x)\nReturn index of whatever element that satisfies the condition\n\n\n\nrank/sort/order can be confusing, so here’s the example.\n\nx &lt;- c(11,14,12,13,15)\nx\n\n[1] 11 14 12 13 15\n\n\n\n# Rank returns the ranking of each element in entire vector\nrank(x)\n\n[1] 1 4 2 3 5\n\n\n\n# Order returns Where the element is located in the original vector if we sorted it\norder(x)\n\n[1] 1 3 4 2 5\n\n\n\n# Sort returns the vector sorted from smallest to biggest\nsort(x)\n\n[1] 11 12 13 14 15",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "Vectors_3.html#vectors-with-boolean",
    "href": "Vectors_3.html#vectors-with-boolean",
    "title": "3  Vectors",
    "section": "3.2 Vectors with Boolean",
    "text": "3.2 Vectors with Boolean\nJust like numeric vectors, you can create vectors with Boolean values (TRUE/FALSE). You can use c() function to create them. You can use T/F instead too.\n\nbooleanvec &lt;- c(TRUE, FALSE, TRUE, TRUE, FALSE)\nbooleanvec\n\n[1]  TRUE FALSE  TRUE  TRUE FALSE\n\n\nSpecial point about the Boolean vectors is that you can use logical operators to create vectors. Let’s say you want to know which students scored higher than 60 on their final.\n\nscores &lt;- c(55, 70, 65, 40, 90)\npassed &lt;- scores &gt; 60\npassed\n\n[1] FALSE  TRUE  TRUE FALSE  TRUE\n\n\n\n3.2.1 Functions you should know for Boolean vectors\nWhile it’s not literally a boolean logic, there are some functions that can be useful when working with Boolean vectors: any/all/if/else\nany() statement returns TRUE if at least one element in the vector is TRUE.\n\nany(passed)\n\n[1] TRUE\n\n\nall() statement returns TRUE only if all elements in the vector are TRUE.\n\nall(passed)\n\n[1] FALSE\n\n\nif and else statements are fundemental for all programming languages. They allow you to control the flow of your program based on conditions. However, we’ll discuss about it briefly here since other contents are heavy as well. If you want to learn more about it, let me know anytime.\nif statement returns true when the condition is met. It’s like a gateway before executing next code. “Do if condition is met? Then move to next line of code. If not, then skip to else statement (or end the if statement).”\nelse statement is executed when the if condition is not met. It’s like the alternative path when the if condition fails.\nBoth if and else statements are wrapped around {}.\nHere’s the example:\n\nIftest &lt;- c(1,3,5,7,9)\n\nif (any(Iftest &gt; 5)) \n  {\n  print(\"At least one element is greater than 5\")\n} else \n  {\n  print(\"No elements are greater than 5\")\n}\n\n[1] \"At least one element is greater than 5\"\n\n\nFor readability, R allows you to combine ifelse into a single line. It looks like this: ifelse(Condition, Value if TRUE, Value if FALSE)\n\nifelse(any(Iftest &gt; 5), \"At least one element is greater than 5\", \"No elements are greater than 5\")\n\n[1] \"At least one element is greater than 5\"",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "Vectors_3.html#vectors-with-text",
    "href": "Vectors_3.html#vectors-with-text",
    "title": "3  Vectors",
    "section": "3.3 Vectors with Text",
    "text": "3.3 Vectors with Text\nJust like other two types, this is just vector with a sequence of text values. You can create them using c() function.\n\nnames &lt;- c(\"Banana\", \"Apple\", \"Carrot\", \"Grape\", \"Whatelse\")\nnames\n\n[1] \"Banana\"   \"Apple\"    \"Carrot\"   \"Grape\"    \"Whatelse\"\n\n\nUnlike numbers, you can’t add or subtract texts. So there’s other ways to handle manipulation of text vectors.\n\n3.3.1 Functions helpful for text vectors\nFirst, we should check if all elements are text, as vector require everything to be same type. But in huge data set, it might be tough to manually check everything. So we have “.ascharacter()” function to convert everything into text.\n\nmixedvec &lt;- c(\"Apple\", 2, \"Banana\", 4.5, TRUE)\nmixedvec &lt;- as.character(mixedvec)\nmixedvec\n\n[1] \"Apple\"  \"2\"      \"Banana\" \"4.5\"    \"TRUE\"  \n\n\nTry code by yourself. Did you notice that all inputs are as text when they were originally text, int, float, bool?\nNow, let’s look at how we can combine and split text vectors like addition/substraction. Both cases, they follow same element wise operation and recycle rule like numeric vectors.\nFor combining text vectors, we can use paste() function. If you want to add space between combined texts, use sep=” ” argument. One point is that you can paste how many vectors you want, but you can call sep =” ” one once per line. So if you want to have different seperators between multiple vectors, you’ll need to call paste() multiple times. So it’ll look like this:\n\nnames &lt;- c(\"Banana\", \"Apple\", \"Carrot\", \"Grape\", \"Whatelse\")\nprice &lt;- c(\"1.00\", \"2.50\", \"0.75\")\ncombined &lt;- paste(names, price, sep=\": $\") #Combine name and price with \": $\" in between\ncombined #Do you notice recycling rule here?\n\n[1] \"Banana: $1.00\"   \"Apple: $2.50\"    \"Carrot: $0.75\"   \"Grape: $1.00\"   \n[5] \"Whatelse: $2.50\"\n\n\nFor spliting text vectors, we can use strsplit() function. When you split, you use split=” ” argument to specify where to split.\n\nsplitnames &lt;- strsplit(combined, split=\": \")\nsplitnames #Name and price are seperated using \":\" as the split point\n\n[[1]]\n[1] \"Banana\" \"$1.00\" \n\n[[2]]\n[1] \"Apple\" \"$2.50\"\n\n[[3]]\n[1] \"Carrot\" \"$0.75\" \n\n[[4]]\n[1] \"Grape\" \"$1.00\"\n\n[[5]]\n[1] \"Whatelse\" \"$2.50\"   \n\n\nThere are many other functions that’s helpful with handling vectors. However, due to it’s amount, we’ll mention only few that’s commonly used.\n\n\n\n\n\n\n\nOpertiona\nDescription\n\n\n\n\nnchar(x)\nReturn character counts of each elements in the vector x. *Literally all characters, including space, are counted!\n\n\nsubstr(x, start, stop)\nReturn character counts of each element in the vector x, starting from ’start’th character to the ’stop’th character.\n\n\ngrep(target, x, ignore.case=T, fixed=T)\nReturn the index of element in vector x that contains “target”. ignore.case asks if you want grep() to be case sensitive (T as yes). fixed asks if you want to use Regex (We don’t be discussing about this here. Keep it true)\n\n\nsub(target, replacement, x, ignore.case=T, fixed=T)\nIf any element in vector x contains “target,” replace it to “replacement.”\n\n\ntoupper(x)\ntolower(x)\nchange all characters in the vector x into upper/lower case",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "Vectors_3.html#other-vectors-with-special-data-tpyes",
    "href": "Vectors_3.html#other-vectors-with-special-data-tpyes",
    "title": "3  Vectors",
    "section": "3.4 Other vectors with special data tpyes",
    "text": "3.4 Other vectors with special data tpyes\nEarlier, we said there’s a special data types. During data analysis, handling these becomes essential as we don’t know how data that doesn’t align with your dataset will influence the general trend (hence analysis result). So let’s briefly look at how to create vectors with these special data types, especially Na and NaN.\n\n3.4.1 Vectors with NA\nNA is used to represent missing values with undetermined data type. For example, if you’re collecting final exam scores but completely missed one student’s score, you can use NA to represent it.\nHow we do process NA without manually checking all data? We can use is.na() and na.omit() functions. is.na() checks if there is NA values, and na.omit() removes all NA values from the vector.\n\nscores &lt;- c(90, 85, NA, 70, 95, NA, 80)\nis.na(scores)  #It'll return TRUE if there's NA in the vector\n\n[1] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE\n\n\n\nscores &lt;- na.omit(scores)  #It'll remove all NA\nscores\n\n[1] 90 85 70 95 80\nattr(,\"na.action\")\n[1] 3 6\nattr(,\"class\")\n[1] \"omit\"\n\n\nLook at the output of na.omit(). Second/Fourth line - attr() shows what type of work is by the code. Ignore them First line - Vector after removing NA values Third line - Attribute showing which index values were removed due to NA Fifth line - What’s done by the code (removing NA values)\nHowever, using is.na() and na.omit() everytime can be time-consuming in big dataset. How can we “ignore” them without removing them? Many functions in R have “na.rm” argument. Setting na.rm=T will ignore NA values during calculation.\n\nscores &lt;- c(90, 85, NA, 70, 95, NA, 80)\nmean(scores, na.rm=T)  #Calculate mean while ignoring NA values\n\n[1] 84\n\n\n\n\n3.4.2 Vectors with NaN\nNaN is used to represent mathematically undefined values. For example, if you try to divide 0 by 0, the result is undefined even thought we know that data type is numbers. In this case, R will return NaN. Just like NA, we can use is.nan() function to check if there’s NaN values in the vector. To know if vector actually contains NaN, you must use is.nan() because is.na() will return TRUE for both NA and NaN.\n\n\n3.4.3 Index\nI mentioned “index” multiple times before, and you probably grasped somewhat sense of what it is. Index is a location of element in the vector. In R, index starts from 1 (not 0 like other programming languages). You can use index to call specific elements in the vector by indicating interested index in []. Here’s the example:\n\nx &lt;- c(10, 20, 30, 40, 50)\nx[3]  #Call the 3rd element in the vector x\n\n[1] 30\n\n\nBut one thing to be careful is that you cannot call two indicies at once. Try x[3,5] and see if it works.\nInstead, you can use c() to connect multiple indices.\n\nx &lt;- c(10, 20, 30, 40, 50)\nx[c(2,4)]  #Call 2nd and 4th elements in the vector x\n\n[1] 20 40",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Vectors</span>"
    ]
  },
  {
    "objectID": "Matrix_4.html",
    "href": "Matrix_4.html",
    "title": "4  Matrix",
    "section": "",
    "text": "4.1 Creating a matrix\nVector was a 1-dimensional data, meaning each vector can hold one type. For example, if we create vector of heights, all elements must be height numbers. However, what if we want need to hold details about the data? For example, height by gender?\nMatrix is a 2-dimensional data structure, holding rows and columns. Just like vector, matrix must hold one type of data.\nThere’s two ways to declare matrix.\nc &lt;- 1:10\n\nm &lt;- matrix(c, nrow = 2, ncol = 5)\nm\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5    7    9\n[2,]    2    4    6    8   10\nHere, did you notice the order of elements? R fills the matrix by column first, then row. If you want to fill by row first, use byrow = TRUE option.\nm &lt;- matrix(c, nrow = 2, ncol = 5, byrow = TRUE)\nm\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    6    7    8    9   10\nv1 &lt;- c(1, 2, 3)\nv2 &lt;- c(4, 5, 6)\nm_row &lt;- rbind(v1, v2)\nm_row\n\n   [,1] [,2] [,3]\nv1    1    2    3\nv2    4    5    6\nm_col &lt;- cbind(v1, v2)\nm_col\n\n     v1 v2\n[1,]  1  4\n[2,]  2  5\n[3,]  3  6\nOne thing to consider is the recycling rule. Whenever you’re working with data sets, having different dimensions will cause shorter data set to repeat.\nv1 &lt;- c(1,2,3)\nv3 &lt;- c(7, 8)\nm_row2 &lt;- rbind(v1, v3)\n\nWarning in rbind(v1, v3): number of columns of result is not a multiple of\nvector length (arg 2)\n\nm_row2\n\n   [,1] [,2] [,3]\nv1    1    2    3\nv3    7    8    7\nWith a same logic, you can create matrix by combining vector with matrix or matrix with matrix using bind() functions.\nc &lt;- 1:10\nrbind(c, 11:20)\n\n  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\nc    1    2    3    4    5    6    7    8    9    10\n    11   12   13   14   15   16   17   18   19    20",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Matrix</span>"
    ]
  },
  {
    "objectID": "Matrix_4.html#creating-a-matrix",
    "href": "Matrix_4.html#creating-a-matrix",
    "title": "4  Matrix",
    "section": "",
    "text": "Dividing vector into rows and columns with matrix()\n\n\n\n\n\nCombining vectors with rbind() and cbind() rbind() combines vectors by row, while cbind() combines by column. This means that rbind() will stack vectors on top of each other, while cbind() will place them side by side.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Matrix</span>"
    ]
  },
  {
    "objectID": "Matrix_4.html#index-of-matrix",
    "href": "Matrix_4.html#index-of-matrix",
    "title": "4  Matrix",
    "section": "4.2 Index of matrix",
    "text": "4.2 Index of matrix\nJust like vector, you can access specific elements of matrix using index. However, since matrix has two dimensions, you need to specify both row and column index.\nWhen you index, you use matrix[row, column] format.Emptying either means “all of them,” and you can also use range like how we created 1,2,3,4 with 1:4.\n\ntest &lt;- matrix(1:25, nrow=5, ncol=5)\ntest\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    6   11   16   21\n[2,]    2    7   12   17   22\n[3,]    3    8   13   18   23\n[4,]    4    9   14   19   24\n[5,]    5   10   15   20   25\n\n\n\ntest[2, 3]  # Access element at 2nd row, 3rd column\n\n[1] 12\n\n\n\ntest[ , 4]  # Access all rows in 4th column\n\n[1] 16 17 18 19 20\n\n\n\ntest[5, 1:3]  # Access 1st-3rd column in 5th row\n\n[1]  5 10 15\n\n\nThere is special about matrix in R. If you use minus, like [, -2], it means “Don’t display (whatever you decide)”. This means that you can manipulate matrix! Look at example below. Do you notice that 6-10 are missing?\n\ntest[ , -2]  # Access all rows except 2nd column\n\n     [,1] [,2] [,3] [,4]\n[1,]    1   11   16   21\n[2,]    2   12   17   22\n[3,]    3   13   18   23\n[4,]    4   14   19   24\n[5,]    5   15   20   25\n\ntest &lt;- test[ , -2]  # By saving \"test matrix without 2nd column\", you can remove 2nd column from original matrix test\n\nLike how matrix fills in order (like column first, then row), when you remove rows or columns, you can manipulate matrix beyond simply removing specific rows or columns. Look at example below. For example, 1:5 mean “1st to 5th row.” Then what will happen if we do 5:1?\n\ntest[5:1, ]  \n\n     [,1] [,2] [,3] [,4]\n[1,]    5   15   20   25\n[2,]    4   14   19   24\n[3,]    3   13   18   23\n[4,]    2   12   17   22\n[5,]    1   11   16   21\n\n\nBecause we’re displaying test matrix from 5th row to 1st row, the order of rows get reversed! Pause and Think: what would test[order(a[, 2]), ] do?\nLike how we filtered out the matrix, we can manipulate them using logical operations. In this case, it only displays elements that’s TRUE. Check example below.\n\npeople &lt;- c(\"John\", \"Jane\", \"Jim\", \"Jill\", \"Jack\")\nAge &lt;- c(28, 34, 29, 42, 23)\nHeight &lt;- c(175, 160, 180, 165, 170)\n\nInformation &lt;- cbind(people, Age, Height) # Imagine what output it would be!\nInformation[ , c(T,F,T)]  # Display only 1st and 3rd column (those with TRUE)\n\n     people Height\n[1,] \"John\" \"175\" \n[2,] \"Jane\" \"160\" \n[3,] \"Jim\"  \"180\" \n[4,] \"Jill\" \"165\" \n[5,] \"Jack\" \"170\" \n\n\n\nInformation[Information[ ,2] &gt; 30, ]  # Display only rows where Age (2nd column) is greater than 30\n\n     people Age  Height\n[1,] \"Jane\" \"34\" \"160\" \n[2,] \"Jill\" \"42\" \"165\" \n\n\nHowever, there is issue with the structure of matrix when we combine multiple vectors. Let’s say you want to investigate average bloodpressure of a patient\n\n# Data with visiting date, bloodpressure, and patient id\nrecord &lt;- matrix(c(\"2023-01-01\", 120, 123,\n                   \"2023-01-02\", 130, 124,\n                   \"2023-01-01\", 125, 456,\n                   \"2023-01-02\", 135, 456), nrow=4, ncol=3, byrow=TRUE)\nrecord\n\n     [,1]         [,2]  [,3] \n[1,] \"2023-01-01\" \"120\" \"123\"\n[2,] \"2023-01-02\" \"130\" \"124\"\n[3,] \"2023-01-01\" \"125\" \"456\"\n[4,] \"2023-01-02\" \"135\" \"456\"\n\nAvg_BP &lt;- mean(as.numeric(record[, 2]))  # Think, why do we need as.numeric() ?\nAvg_BP\n\n[1] 127.5\n\n\nBut you realized that you forgot the heights of patients, and you create new matrix.\n\n# Data with visiting date, height, bloodpressure, and patient id\nrecord_fix &lt;- matrix(c(\"2023-01-01\", 150, 120, 123, \n                       \"2023-01-02\", 150, 130, 124,\n                       \"2023-01-01\", 150, 125, 456, \n                       \"2023-01-02\", 150, 135, 456), nrow=4, ncol=4, byrow=TRUE)\nAvg_BP &lt;- mean(as.numeric(record_fix[, 2]))  # Run the same code again\nAvg_BP\n\n[1] 150\n\n\nAfter fixing the matrix, running same code that gave us average blood pressure is giving us wrong result! This is because adding new column shifted location of existing information. Then how can we track which information is where? This is where rownames() and colnames() takes place to assign titles to rows and columns.\n\ncolnames(record_fix) &lt;- c(\"Date\", \"Height\", \"BloodPressure\", \"PatientID\")\nrecord_fix\n\n     Date         Height BloodPressure PatientID\n[1,] \"2023-01-01\" \"150\"  \"120\"         \"123\"    \n[2,] \"2023-01-02\" \"150\"  \"130\"         \"124\"    \n[3,] \"2023-01-01\" \"150\"  \"125\"         \"456\"    \n[4,] \"2023-01-02\" \"150\"  \"135\"         \"456\"    \n\n\nNow, we can access information by their names, not by their index. This way, even if we add new information, we can still access existing information without worrying about shifting index.\n\nAvg_BP &lt;- mean(as.numeric(record_fix[ , \"BloodPressure\"]))\nAvg_BP\n\n[1] 127.5\n\n\nGreat fix! By the way, review old matrices like “Information” or m_row, and compare to “record.” Do you notice two have colnames while one doesn’t? This is where creating matrix by combining vectors (rbind, cbind) is better than creating matrix by dividing single vector (how we made record). When you use rbind() and cbind(), they recognize names of vectors, thinking “these values belong under the name of the vector!” As result, functions automatically assign colnames() or rownames() using vector names.\nOne last thing, matrix is 2x2. What if you only give one index like how we did in vector indexing? In matrix, inputing one index means matrix will behave like a vector. So, like how matrix fills by column first and then rows, matrix[i] will return index after scanning column and row order.\n\nlast &lt;- matrix(1:9, nrow=3, ncol=3)\nlast\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\nlast[5] # Since it's 3x3, 5th index will be [2,2]. 1st column (3 elements), and 2nd column's 2nd element. \n\n[1] 5\n\nlast[last &gt; 5]  # Returns all elements greater than 5 as 1-dimensional vector\n\n[1] 6 7 8 9",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Matrix</span>"
    ]
  },
  {
    "objectID": "Matrix_4.html#calculation-of-matrix",
    "href": "Matrix_4.html#calculation-of-matrix",
    "title": "4  Matrix",
    "section": "4.3 Calculation of matrix",
    "text": "4.3 Calculation of matrix\nBefore we get into calculation of matrix, you should know the math behind matrix calculation. Please review concepts regarding matrix, adding/subtracting/multiplying matrices. Others are good to know but optional. Link is here\n\nNow let’s try calculating matrix in R. First, creating two matrices with same dimension.\n\nA &lt;- matrix(1:9, nrow=3, ncol=3)\nB &lt;- matrix(9:1, nrow=3, ncol=3)\nA\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\nB\n\n     [,1] [,2] [,3]\n[1,]    9    6    3\n[2,]    8    5    2\n[3,]    7    4    1\n\n\n\nA + B\n\n     [,1] [,2] [,3]\n[1,]   10   10   10\n[2,]   10   10   10\n[3,]   10   10   10\n\nB - A\n\n     [,1] [,2] [,3]\n[1,]    8    2   -4\n[2,]    6    0   -6\n[3,]    4   -2   -8\n\nA * B\n\n     [,1] [,2] [,3]\n[1,]    9   24   21\n[2,]   16   25   16\n[3,]   21   24    9\n\nA / B\n\n          [,1]      [,2]     [,3]\n[1,] 0.1111111 0.6666667 2.333333\n[2,] 0.2500000 1.0000000 4.000000\n[3,] 0.4285714 1.5000000 9.000000\n\n\nGreat! R is doing element-wise calculation. This means that R is adding/subtracting/multiplying/dividing each element in same position. For example, A[1,1] + B[1,1], A[1,2] + B[1,2], and so on.\nOne question, do matrix follow recycling rule? Try making two matricies with different dimension and adding them. You’ll see the error - R cannot perform calculations that violates fundemental rules of math. However, when you’re using vector and matrix, vectors can be recycled.\n\nC &lt;- c(0, 10, 100)\n\nA + C\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]   12   15   18\n[3,]  103  106  109\n\n\nHowever, we should keep in mind that vector should be shorter than the number of elements in the matrix. If vector is longer, what are we adding leftover vector elements with?",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Matrix</span>"
    ]
  },
  {
    "objectID": "Matrix_4.html#functions-regarding-matrix",
    "href": "Matrix_4.html#functions-regarding-matrix",
    "title": "4  Matrix",
    "section": "4.4 Functions regarding matrix",
    "text": "4.4 Functions regarding matrix\n\nnrow(), ncol(), dim() How do we know size of unknown matrix? nrow() and ncol() returns number of rows and columns, while dim() returns both as vector. dim() returns column size first! Don’t get confused with [row, column] in indexing.\n\n\nm &lt;- matrix(1:12, nrow=3, ncol=4)\nnrow(m)\n\n[1] 3\n\nncol(m)\n\n[1] 4\n\ndim(m)\n\n[1] 3 4\n\n\n\nrownames(), colnames() Earlier, we saw how we can assign row names and column names by rownames() &lt;- c(names). However, can we do the opposite? Like, checking names of cols and rows instead of assigning? Yes! Instead of assigning through &lt;-, you can use rownames(matrix) or colnames(matrix) to check names of rows and columns.\n\n\ncolnames(m) \n\nNULL\n\nrownames(m)\n\nNULL\n\n\nHere, we get Null (empty). Why is that? Look at how m looks like and think about it!\n\nt() Transpose matrix is matrix with switched rows and columns (for example, 2x3 becomes 3x2). In R, you can do this by t() function.\n\n\nm\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\nt(m)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n[4,]   10   11   12\n\n\n\nMoving between matrix and vector Sometimes, you may want to convert matrix into vector or vice versa. You can do this by as.vector() or c(). as.vector() unstrings matrix into single line (= vector). And do you remember how giving one input feature in indexing make matrix behave like vector? c() function does the same thing. If you do c(matrix) without telling what else to combine with, c() will combine matrix itself into one string, making it vector.\n\n\nTestmat &lt;- matrix(1:9, nrow=3, ncol=3)\nas.vector(Testmat)\n\n[1] 1 2 3 4 5 6 7 8 9\n\nc(Testmat)\n\n[1] 1 2 3 4 5 6 7 8 9\n\n\n\nApply() Often, we need to perform calculation throughout row or column of the matrix (e.g. finding average height by each person, finding total score by each student). Instead of writing all elements individually, we can use apply() function.\n\napply() has three main arguments (inputs). X (target), Margin (which direction do you want to apply the function? 1 is row, 2 is column), and Function (work you want to perform)\n\nScores &lt;- matrix(c(90, 85, 88,\n                   78, 92, 80,\n                   85, 87, 90), nrow=3, byrow=TRUE)\ncolnames(Scores) &lt;- c(\"Math\", \"Science\", \"English\")\nScores\n\n     Math Science English\n[1,]   90      85      88\n[2,]   78      92      80\n[3,]   85      87      90\n\n#Let's find average score of each subjects\nmath_avg &lt;- (Scores[1,1] + Scores[2,1] + Scores[3,1]) / 3\nmath_avg\n\n    Math \n84.33333 \n\n#Doing this for each column is annoying. Let's use apply()\nexam_avg &lt;- apply(Scores, 2, mean) # Find mean (function) of matrix (Scores) by column (2)\nexam_avg\n\n    Math  Science  English \n84.33333 88.00000 86.00000",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Matrix</span>"
    ]
  },
  {
    "objectID": "Matrix_4.html#creating-an-array",
    "href": "Matrix_4.html#creating-an-array",
    "title": "4  Matrix",
    "section": "5.1 Creating an array",
    "text": "5.1 Creating an array\nWe can declare by matrix in a similar way to how we declared vectors. 1. Define matricies you want to stack 2. Use array() function to stack them * Remember, dimension should be identical to be able to stack them.\n\nmat1 &lt;- matrix(1:6, nrow=2, ncol=3)\nmat2 &lt;- matrix(7:12, nrow=2, ncol=3)\narr &lt;- array(c(mat1, mat2), dim = c(2, 3, 2)) # 2 rows, 3 columns, 2 layers\narr\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n\n\nUnlike how matrix or vectors were single layer, you’ll see that 3D array has layers, shown as “, , 1” and “, , 2”. Arrays fill data just like matrix. Column first, then rows (next columns), then layers. In the same way, you can index them. Array[row, column, layer]. If you expand it to 4,5,6th dimensions? You just keep adding commas! For example, array[row, column, layer, 4th dimension, 5th dimension]\nIt is difficult to imagine it, so I’ll visualize 3D array we made (arr) below.\n\n\n\n\n\nJust like colnames and rownames in matrix, you can assign names to each dimension using dimnames() function.\n\ndimnames(arr) &lt;- list(\n  Row = c(\"R1\", \"R2\"),\n  Column = c(\"C1\", \"C2\", \"C3\"),\n  Layer = c(\"L1\", \"L2\")\n)\narr\n\n, , Layer = L1\n\n    Column\nRow  C1 C2 C3\n  R1  1  3  5\n  R2  2  4  6\n\n, , Layer = L2\n\n    Column\nRow  C1 C2 C3\n  R1  7  9 11\n  R2  8 10 12\n\n\nNow, you can index using names too!\n\narr[\"R1\", \"C2\", \"L1\"]\n\n[1] 3\n\n\nHowever, there is one thing that you should be careful. Let’s look at the example below\n\narr[1, 2:3, 1:2] # Access 1st row, 2nd-3rd column, all layers\n\n      Layer\nColumn L1 L2\n    C2  3  9\n    C3  5 11\n\n\nWe asked them to display first row, 2nd-3rd column, all layers: 3D data. However, output is 2x2 matrix, a 2D data. Like this, when R can display result in lower dimension, it will do it. If you want to keep the original dimension, use drop = False argument. If you look at the example below, you’ll see that output is seperated into two layers again.\n\narr[1, 2:3, 1:2, drop = FALSE] \n\n, , Layer = L1\n\n    Column\nRow  C2 C3\n  R1  3  5\n\n, , Layer = L2\n\n    Column\nRow  C2 C3\n  R1  9 11",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Matrix</span>"
    ]
  },
  {
    "objectID": "Matrix_4.html#calculation-of-array",
    "href": "Matrix_4.html#calculation-of-array",
    "title": "4  Matrix",
    "section": "5.2 Calculation of Array",
    "text": "5.2 Calculation of Array\nOmitted. Everything is same as Matrix calculation.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Matrix</span>"
    ]
  },
  {
    "objectID": "Matrix_4.html#advanced-caluclation",
    "href": "Matrix_4.html#advanced-caluclation",
    "title": "4  Matrix",
    "section": "5.3 Advanced caluclation",
    "text": "5.3 Advanced caluclation\n\n5.3.1 Solving equations with matrix\nMatrix and Array can be used in a lot of places. Due to its compact representation of high dimnesional data, we often use matrix to represent equations with multiple dimension. For example,\n3x + 2y = 5 4x + 6y = 12\ncan be written as [3, 2, 5]; [4, 6,12] (; is used to seperate rows). So, we condensed multiple equations into one 2x3 matrix. This also means that we can use matrix to solve complex equations.\nUsing the matrix above as example, we have two parts: variables (x and y), and constants (5 and 12). We can separate them into two matrices:\n\nA &lt;- matrix(c(3, 2,\n              4, 6), nrow=2, byrow=TRUE) # Coefficient matrix\nB &lt;- matrix(c(5, 12), nrow=2) # Constant matrix\ncolnames(A) &lt;- c(\"x\", \"y\")\n\nNow, you can just use solve() to find values of x and y!\n\nsolution &lt;- solve(A, B)\nsolution\n\n  [,1]\nx  0.6\ny  1.6\n\n\n\n\n5.3.2 Eigenvalues and Eigenvectors\nThis is core concept of linear algebra, which will help you understand more advanced machine learning algorithms. However, it’s difficult to understand without proper math background, so we’ll come back to this later. For now, watch this playlist to get introduction to linear algebra. I highly recommend this.\nLink: Linear Algebra by 3Blue1Brown",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Matrix</span>"
    ]
  }
]